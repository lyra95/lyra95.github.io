[{"content":"Markdown here\n","description":"test post","id":0,"section":"updates","tags":null,"title":"May 2019","uri":"https://lyra95.github.io/updates/2019_may/"},{"content":"Markdown here\n","description":"test post","id":1,"section":"updates","tags":null,"title":"April 2019","uri":"https://lyra95.github.io/updates/2019_april/"},{"content":"Markdown here\n","description":"test post","id":2,"section":"updates","tags":null,"title":"March 2019","uri":"https://lyra95.github.io/updates/2019_march/"},{"content":"Markdown here\n","description":"test post","id":3,"section":"updates","tags":null,"title":"February 2019","uri":"https://lyra95.github.io/updates/2019_february/"},{"content":"Markdown here\n","description":"test post","id":4,"section":"updates","tags":null,"title":"January 2019","uri":"https://lyra95.github.io/updates/2019_january/"},{"content":"package 적용할 버젼을 더 엄격하게 적용할 때 사용함\npackage-lock.json이 있다면 npm install 대신 npm ci를 하자\n","description":"","id":5,"section":"docs","tags":[],"title":"package-json.lock이 뭘까","uri":"https://lyra95.github.io/docs/nodejs/honey-tip/"},{"content":"Restful Api란? 특정 약속으로 정해놓은 server-client application 규약이다.\nHTTP( or HTTPS) 통신을 이용하여 server와 client간 데이터를 주고받는다.\n보통 4가지 오퍼레이션이 있다: get, put, post, delete. 각각 Read, Update, Create, Delete에 대응된다고 보면된다.\n예를들어서, 학생들 성적을 관리하는 서버가 있다고 치자. 1번 학생의 성적을 보고 싶다면 get https://{서버주소}/students/1 이런식으로 요청한다. 무엇을 하려고 하는지 링크(URI)자체로 설명이 되고 있다.\n그외에도 stateless, cache 등등 여러가지 규약이 있는데, (https://restfulapi.net/)[https://restfulapi.net/]를 참고하는게 더 좋을 것이다.\n간단한 server-client application을 쉽게 찍어내기 위한 설계도라고 이해하면 될 것 같다.\n준비물 python의 flask framework를 이용해서 restful api 서버를 만들어보자.\n python의 django, javascript의 node.js 등 다른 선택지도 많다. flask가 쉽고 간단해 보여서 선택했다.\n 필요 패키지들은(requirements.txt) 다음과 같다.\n 이 txt파일을 프로젝트 최상위에 두고, pip install -r requirements.txt로 한꺼번에 다운받을 수 있다.\n 1 2 3 4 5 6 7 8 9 10 11 12 13  aniso8601==8.0.0 click==7.1.2 Flask==1.1.2 Flask-RESTful==0.3.8 Flask-SQLAlchemy==2.4.3 Flask-Caching==1.0.0 itsdangerous==1.1.0 Jinja2==2.11.2 MarkupSafe==1.1.1 pytz==2020.1 six==1.15.0 SQLAlchemy==1.3.18 Werkzeug==1.0.1   Minimal API 대충 아래 처럼 사용한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33  #main.py from flask import Flask from flask_restful import Api, Resource app = Flask(__name__) api = Api(app) config = { \u0026#34;DEBUG\u0026#34;: True, # some Flask specific configs \u0026#34;CACHE_TYPE\u0026#34;: \u0026#34;SimpleCache\u0026#34;, # Flask-Caching related configs \u0026#34;CACHE_DEFAULT_TIMEOUT\u0026#34;: 300 } # tell Flask to use the above defined config app.config.from_mapping(config) # 데이터가 저장되는 곳 videos = { 1:{\u0026#39;name\u0026#39;:\u0026#39;HelloWorld\u0026#39;, \u0026#39;views\u0026#39;:147, \u0026#39;likes\u0026#39;:3} } class Video(Resource): def get(self,video_id): return videos[video_id], def delete(self,video_id): del videos[video_id] return {}, 204 api.add_resource(Video,\u0026#34;/videos/\u0026lt;int:video_id\u0026gt;\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: app.run(debug=True)   추가 설명 아래와 같이 flask를 initialzation하고 configure할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13  from flask import Flask from flask_restful import Api, Resource app = Flask(__name__) api = Api(app) config = { \u0026#34;DEBUG\u0026#34;: True, # some Flask specific configs \u0026#34;CACHE_TYPE\u0026#34;: \u0026#34;SimpleCache\u0026#34;, # Flask-Caching related configs \u0026#34;CACHE_DEFAULT_TIMEOUT\u0026#34;: 300 } # tell Flask to use the above defined config app.config.from_mapping(config)   Debug 모드로 실행하고자 할 때 다음을 추가한다.\n1 2 3  if __name__ == \u0026#34;__main__\u0026#34;: app.run(debug=True)   다음과 같이 Resource를 상속받아서 class를 구현하고 get,put,post,delete 등등을 구현한다.\n1 2 3 4 5 6 7 8 9  class Video(Resource): def get(self,video_id): return videos[video_id], def delete(self,video_id): del videos[video_id] return {}, 204 api.add_resource(Video,\u0026#34;/videos/\u0026lt;int:video_id\u0026gt;\u0026#34;)   마지막 줄은 일종의 라우터로, 클라이언트가 https://서버주소/videos/3과 같이 서버에 접근할 수 있도록 해준다.\n만일 클라이언트가 get https://서버주소/videos/1을 요청한다면, {'name':'HelloWorld', 'views':147, 'likes':3}가 반환될 것이다.\n테스트 먼저 서버를 실행한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  PS C:\\dev\\flask-rest-api-tuto\u0026gt; python main.py * Serving Flask app \u0026#34;main\u0026#34; (lazy loading) * Environment: production WARNING: This is a development server. Do not use it in a production deployment. Use a production WSGI server instead. * Debug mode: on * Restarting with stat * Debugger is active! * Debugger PIN: 171-188-332 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit) * Detected change in \u0026#39;C:\\\\dev\\\\flask-rest-api-tuto\\\\main2.py\u0026#39;, reloading * Restarting with stat * Debugger is active! * Debugger PIN: 171-188-332 * Running on http://127.0.0.1:5000/ (Press CTRL+C to quit)   http://127.0.0.1:5000/가 서버의 주소라고 나와있다.\n크롬, 파이어폭스 확장 기능 중에 rest api 클라이언트 어플리케이션이 있다.\n혹은 request 패키지를 이용해 .py파일로 테스트할 수 있다.\n1 2 3 4 5 6 7  #test.py import requests BASE = \u0026#34;http://127.0.0.1:5000/\u0026#34; response = requests.get(BASE + \u0026#34;videos/1\u0026#34;) print(response.json())   1 2  PS C:\\dev\\flask-rest-api-tuto\u0026gt; python test.py [{\u0026#39;name\u0026#39;: \u0026#39;HelloWorld\u0026#39;, \u0026#39;views\u0026#39;: 147, \u0026#39;likes\u0026#39;: 3}]   다음 포스트에서는 클라이언트의 리퀘스트를 reqparse 패키지를 활용해 파싱하는 법을 설명할 것이다. 이를 이용해 put 요청을 구현할 수 있다.\nflask_caching 패키지를 활용해서 캐시 기능을 구현할 것이다. get https://서버주소/videos/1가 여러번 요청되었을 때, 해당 데이터가 업데이트/삭제되지 않았다면, 캐시를 활용해 예전에 계산된 결과를 반환하게 함으로써 서버의 부하를 줄이고 송수신 시간을 단축할 수 있다.\n그 다음 포스트에서는 flask_sqlalchemy 패키지와 sqlalchemy, sqlite를 활용하여 서버가 데이터베이스와 연계하도록 구현할 것이다. (지금은 그냥 videos라는 파이썬 딕셔너리에 데이터가 저장되어있는데, 이를 데이터베이스로 치환할 것이다.)\nReference  https://flask-restful.readthedocs.io/en/latest/ Python REST API Tutorial - Building a Flask REST API  ","description":"","id":6,"section":"docs","tags":["python","flask","rest api"],"title":"Flask로 Restful Api (1): 기본 API","uri":"https://lyra95.github.io/docs/flask/rest-api-1/"},{"content":"디렉토리 이동\ncd {path}\n디렉토리 만들기\nmkdir {path}\n디렉토리 내용물보기\nls\n-a 숨김파일도 보기\n파일 내용물 보기\ncat {path}\n","description":"","id":7,"section":"docs","tags":["linux","command"],"title":"Linux command","uri":"https://lyra95.github.io/docs/git/linux_command/"},{"content":"git docs\ngit 관리모듈 생성\ngit init {path}\nvirsion history 보기\ngit log\n\u0026ndash;stat 수정된 파일과 몇 line 수정됬는지 자세히 보기\n-p\n바뀐 status 보기\ngit status\n변경사항 staging\ngit add {filename}\n새 버젼 만들기\ngit commit\n-m {msg}\n업로드\ngit push\n차이점 보기\ngit diff\n마지막 버전으로 돌아가기\ngit reset \u0026ndash;hard\n특정 버전으로 이동(commit ID는 git log로 볼 수 있음)\ngit checkout {commit ID}\ngit checkout {branch name}\n특정 버전으로 리셋(그 버전 이후 버전들 삭제됨)\ngit reset \u0026ndash;hard {commit ID}\n특정 버전으로 revert(commit ID 직전 버전으로 시점이 이동하고, commit을 새로 생성함)\ngit revert {commit ID}\n(What is the meaning of revert this commit and roll back this commit in GitHub for Windows?)[https://stackoverflow.com/questions/15039271/what-is-the-meaning-of-revert-this-commit-and-roll-back-this-commit-in-github-fo]\n텍스트 에디터 바꾸기\ngit config \u0026ndash;global core.editor \u0026ldquo;vim\u0026rdquo;\n","description":"","id":8,"section":"docs","tags":["git"],"title":"Git command list","uri":"https://lyra95.github.io/docs/git/gitcommand/"},{"content":"문제 Visual Studio 2019\nWindows 10 64bits\nC++17\n컴파일했을 때 수많은 C2760 메시지와 syntax가 전혀 틀리지 않았는데도 ;나 ) 따위에 틀렸다고 뜰 때.\n해결 Go to project property -\u0026gt; C/C++ -\u0026gt; Language -\u0026gt; Conformance mode. Set it to No(/permissive).\nreference 모던 C++과 컴파일러의 호환 문제인가 싶다. 컴파일러를 C++17로 설정했는데도 나타나는 문제다. MS는 버그가 아니라 우기는데 사람들은 화나서 비추주는 중.\nhttps://developercommunity.visualstudio.com/t/error-c2760-in-combaseapih-with-windows-sdk-81-and/185399\n","description":"","id":9,"section":"docs","tags":["bug","cpp","vs2019"],"title":"error C2760: syntax error: unexpected token 'identifier', expected 'type specifier'","uri":"https://lyra95.github.io/docs/configurations/c2760/"},{"content":"출처\n둘 다 클래스 인스턴스를 생성하지 않고 메서드를 사용하는 법(정적메서드)과 관련되어있다.\n@staticmethod 1 2 3 4 5 6 7 8 9 10 11  class Test : num = 0 @staticmethod def add (x, y) : return x + y print(Test.add(1,1)) t = Test() print(t.add(1,1)) # allowed, but not recommended   객체를 통한 정적메소드 접근은 C#에서는 에러, Java, C++에서는 warning이라고 한다.\n1 2 3 4 5 6 7 8 9 10 11  class Test : num = 0 @staticmethod def add (x, y) : return x + y + self.num print(Test.add(1,1)) # error t = Test() print(t.add(1,1)) # error   class 생성까지는 문제가 안되지만 add를 콜할 때 self가 정의되지 않다고 에러가 뜬다. (self를 파라미터로 받지 않았으니\u0026hellip;)\n굳이 이렇게 헷갈릴만한 코드를 쓰느니 class 바깥으로 빼는게 좋다고 생각하는 사람들도 있다.\n@classmethod cls를 파라미터로 꼭 넣어줘야 한다.\n1 2 3 4 5 6 7 8 9 10 11  class Test : num = 10 @classmethod def add (cls, x, y) : return x + y print(Test.add(1,1)) # work t = Test() print(t.add(1,1)) # work, but not recommended   차이점 상속(inheritance)가 있으면 차이가 발생한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Date : word = \u0026#39;date : \u0026#39; def __init__(self, date): self.date = self.word + date @staticmethod def now(): return Date(\u0026#34;today\u0026#34;) def show(self): print(self.date) class KoreanDate(Date): word = \u0026#39;날짜 : \u0026#39; d = KoreanDate.now() # Date\u0026#39;s instance, not KoreanDate\u0026#39;s d.show() # date : today, unexpected   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20  class Date : word = \u0026#39;date : \u0026#39; def __init__(self, date): self.date = self.word + date @staticmethod def now(cls): return cls(\u0026#34;today\u0026#34;) def show(self): print(self.date) class KoreanDate(Date): word = \u0026#39;날짜 : \u0026#39; d = KoreanDate.now() # KoreanDate\u0026#39;s instance d.show() # 날짜 : today, as expected   cls는 콜 될 때의 클래스가 된다. (KoreanDate로 콜됬으니 cls=KoreanDate)\n@staticmethod는 왜 있는지 모르겠다는 악평이 많은듯 하다.\n","description":"","id":10,"section":"docs","tags":["syntax","python"],"title":"@staticmethod 와 @classmethod의 차이","uri":"https://lyra95.github.io/docs/python/python1/"},{"content":"가이드대로 차근차근 따라한다. (Windows 10 64bits)\nPrerequisites   python 3.xx가 설치 되었는가?\n터미널에서 python으로 버젼 확인 가능\n  pip3가 설치되었는가?\n터미널에서 pip3를 실행해서 확인\n  CUDA가 설치되었는가?\n CUDA가 지원되는 GPU인가? CUDA ver. 10.x or 11.x?    Install 가이드 링크 상단 참조\nCheck pytorch 설치 확인\n1 2 3 4 5 6 7 8 9 10 11  PS C:\\Windows\\system32\u0026gt; python Python 3.9.4 (tags/v3.9.4:1f2e308, Apr 6 2021, 13:40:21) [MSC v.1928 64 bit (AMD64)] on win32 Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; import torch \u0026gt;\u0026gt;\u0026gt; x = torch.rand(5,3) \u0026gt;\u0026gt;\u0026gt; print(x) tensor([[0.3259, 0.3376, 0.0448], [0.1390, 0.5901, 0.6815], [0.6117, 0.7122, 0.8342], [0.8501, 0.0681, 0.7899], [0.7258, 0.3614, 0.1571]])   CUDA enabled 확인 (위에서 이어서)\n1 2 3  \u0026gt;\u0026gt;\u0026gt; import torch \u0026gt;\u0026gt;\u0026gt; torch.cuda.is_available() True   ","description":"","id":11,"section":"docs","tags":["setting","pytorch","cuda","ml","machine learning"],"title":"Pytorch Install (local)","uri":"https://lyra95.github.io/docs/ml/install-local/"},{"content":"실행 환경 OS : windows 10 64bits\nssh : openSSH\nSetup EC2/User Guide for Linux Instances/Set up을 참고했다.\n다운받은 {key-pair-name}.pem은 어디 까먹지 않을 경로에 둔다.\n주의\nCreate a key pair 스텝을 진행하는 과정에서, 다음과 같은 설명이 있다.\n If you will use an SSH client on a macOS or Linux computer to connect to your Linux instance, use the following command to set the permissions of your private key file so that only you can read it.\nchmod 400 my-key-pair.pem\nIf you do not set these permissions, then you cannot connect to your instance using this key pair. For more information, see Error: Unprotected private key file.   macOS or Linux라길래 가볍게 무시하고 넘어갔는데, 나중에 연결할 때 바로 Error: Unprotected private key file. 에러가 발생했다. 링크를 참고해서 key pair의 permission을 변경해주자.\nLaunch an Instance EC2/userguide/get started tutorial\n그대로 참고했다.\nSecurity Group은 setup 단계대로 제대로 생성하는게 보안에 좋아보인다.\nConnect to Instance 가이드에 따르면, 다음 커맨드로 방금 만든 인스턴스에 접속할 수 있다.\n1  ssh -i /path/my-key-pair.pem my-instance-user-name@my-instance-public-dns-name    openSSH가 설치되어 있는가? key-pair path를 제대로 입력했는가? my-instance-user-name을 제대로 입력했는가? my-instance-public-dns-name을 제대로 입력했는가? key-pair 파일의 permission을 제대로 설정했는가? Error: Unprotected private key file.  public dns name은 aws ec2 console 페이지의 instance로 들어가서 확인할 수 있다.\nssh 커맨드에 -vvv를 추가하면 진행 상황에 대한 상세한 설명이 출력된다. 출력된 내용을 보고 아마존 트러블슈팅 페이지를 참고하자.\n기본 user-name을 ec2-user이다. 사용자를 추가하고싶으면 링크 참고.\n","description":"","id":12,"section":"docs","tags":["aws","ec2","server"],"title":"aws EC2 server instance 생성","uri":"https://lyra95.github.io/docs/aws/ec2-1/"},{"content":"pycahce,ps1같은 파일을 깃헙에 올리고 싶지는 않을 것이다.\n이를 제외하려면 다음과 같이 하면된다.\n 프로젝트 최상위 디렉토리에 .gitignore 파일 생성 무시하고자하는 파일, 디렉토리를 .gitignore에 작성  와일드카드를 써서 ps1파일을 싹다 제외시켰다.\n*.ps1 .vscode/ ","description":"","id":13,"section":"docs","tags":["git"],"title":".gitignore로 일부 파일 제외하기","uri":"https://lyra95.github.io/docs/git/git-ignore/"},{"content":"문제 hugo라는 프레임워크로 블로그를 관리하고 있는데, 변경된 내역을 업데이트하려면 여러 번의 커맨드를 실행해야한다.\n1 2 3 4 5 6 7 8 9  hugo -t \u0026#34;zdoc\u0026#34; cd public git add . git commit -m \u0026#39;.\u0026#39; git push cd .. git add . git commit -m \u0026#39;.\u0026#39; git push   매번 타자를 치는 것도 손이 아파서 뭔가 방법이 없나 했다.\n 귀찮음이 프로그래머를 성장시킨다\n 방법 text파일을 하나 만들고 실행하고자 할 커맨드를 다 작성한다.\n1 2 3 4 5 6 7 8 9  hugo -t \u0026#34;zdoc\u0026#34; cd public git add . git commit -m \u0026#39;.\u0026#39; git push cd .. git add . git commit -m \u0026#39;.\u0026#39; git push   다른 이름으로 저장 -\u0026gt; 모든 확장자 -\u0026gt; {이름}.ps1 으로 저장한다.\npowershell을 실행해서 ./{이름}을 입력하면 저 커맨드들이 한꺼번에 실행된다.\n나는 왜 안되지 하는 분들께 powershell이 이런식으로 ps1파일을 읽어와서 실행하는 것을 default로 막아놨다.\n그 설정을 변경하려면 powershell을 관리자로 실행한 뒤 Set-ExecutionPolicy RemoteSigned를 입력하면 된다.\n 출력되는 보안 이슈에 관한 설명을 꼭 읽고나서 설정을 바꾸세요\n 1 2 3 4 5 6 7  PS C:\\Windows\\system32\u0026gt; Set-ExecutionPolicy RemoteSigned Execution Policy Change The execution policy helps protect you from scripts that you do not trust. Changing the execution policy might expose you to the security risks described in the about_Execution_Policies help topic at https:/go.microsoft.com/fwlink/?LinkID=135170. Do you want to change the execution policy? [Y] Yes [A] Yes to All [N] No [L] No to All [S] Suspend [?] Help (default is \u0026#34;N\u0026#34;): Y   누군가 원격으로 내 컴퓨터에 접속해서 미리 작성해둔 ps1 스크립트를 실행해버릴 수도 있다는 생각이 들지만 털어봐야 아무것도 없어서 저는 쿨하게 Y를 누릅니다.\n","description":"","id":14,"section":"docs","tags":["powershell","ps1"],"title":"ps1 파일로 powershell command 한 번에 실행하기","uri":"https://lyra95.github.io/docs/powershell/powershell-ps1/"},{"content":"Installation 설치 환경: Windows 10 64bit\n통합 패키지 wamp를 받습니다.(파일명 bitnami-wampstack-8.0.5-0-windows-x64-installer)\nComponent는 모두 선택합니다.\n php 관련 framework등 지금은 필요없는 구성들이 있지만, 일단은 선택합니다.\n 설치경로를 기억해둡시다. (필자의 경우 C:\\Bitnami\\wampstack-8.0.5-0)\nroot 어카운트 비밀번호는 아무거나 설정합니다.\n 단순 개인 프로젝트라면 111111같은 비번도 괜찮겠지만, 보안이 중요하다면 복잡한 비밀번호로 설정하세요\n cloud는 필요없으니 선택하지 않습니다.\n Mac, Linux 같은 다른 OS의 경우, 혹은 현재 instruction을 따라하기 힘든 경우, 필자가 참고한 생활코딩1 영상이나 다른 정보를 활용하세요.\n Start Server by GUI 설치경로에 manager-windows.exe 파일을 클릭해서 실행합니다.\nManage Servers 탭에서 MySQL Database를 클릭하고 Start를 클릭합니다. 초록색으로 점등이 되고 Running으로 Status가 바뀌면 서버가 켜진 것입니다.\n서버를 끌 때는 Stop을 누르고 빨간색으로 점등이 되는 것을 확인하세요.\nMySQL 실행 서버를 켜고 mysql을 실행해봅시다.\n{설치경로}\\mysql\\bin 에서 터미널 창 오픈해서 mysql -uroot -p 커맨드 입력합니다.\n 매번 경로를 입력하기 귀찮으면 환경변수 path에 등록해둡시다.\n 비밀번호를 입력하라고 할 텐데, 설치할 때 정했던 비번입니다. 성공할 시 터미널 출력결과가 다음과 비슷할 것입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  PS C:\\Bitnami\\wampstack-8.0.5-0\\mysql\\bin\u0026gt; mysql -uroot -p Enter password: ****** Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 8 Server version: 8.0.24 MySQL Community Server - GPL Copyright (c) 2000, 2021, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. mysql\u0026gt;   exit 커맨드로 mysql을 종료할 수 있습니다.\nStart Server from Terminal2 server가 켜져 있는지 확인해봅니다:\n1 2 3 4  PS C:\\Bitnami\\wampstack-8.0.5-0\\mysql\\bin\u0026gt; mysql -u root -p Enter password: ****** ERROR 2003 (HY000): Can\u0026#39;t connect to MySQL server on \u0026#39;localhost:xxxx\u0026#39; (10061) PS C:\\Bitnami\\wampstack-8.0.5-0\\mysql\\bin\u0026gt;   서버가 꺼져있습니다. {설치경로}\\mysql\\bin에서 터미널을 켜고 mysqld 커맨드를 입력합니다.\n1 2  PS C:\\Bitnami\\wampstack-8.0.5-0\\mysql\\bin\u0026gt; mysqld _   서버가 켜진 동안 커맨드가 완료되지 않을 것입니다. 새로운 터미널 창을 열고 mysql을 실행할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  PS C:\\Bitnami\\wampstack-8.0.5-0\\mysql\\bin\u0026gt; mysql -u root -p Enter password: ****** Welcome to the MySQL monitor. Commands end with ; or \\g. Your MySQL connection id is 8 Server version: 8.0.24 MySQL Community Server - GPL Copyright (c) 2000, 2021, Oracle and/or its affiliates. Oracle is a registered trademark of Oracle Corporation and/or its affiliates. Other names may be trademarks of their respective owners. Type \u0026#39;help;\u0026#39; or \u0026#39;\\h\u0026#39; for help. Type \u0026#39;\\c\u0026#39; to clear the current input statement. mysql\u0026gt; exit Bye   서버를 종료하기 위해서는 root 권한이 필요합니다. 서버를 종료하기 위해 mysqladmin -u root -p shutdown를 입력합니다.\n1 2 3  PS C:\\Bitnami\\wampstack-8.0.5-0\\mysql\\bin\u0026gt; mysqladmin -u root -p shutdown Enter password: ****** PS C:\\Bitnami\\wampstack-8.0.5-0\\mysql\\bin\u0026gt;   서버가 종료되면서, 서버를 실행시켰던 터미널에서 커맨드가 완료되었을 것입니다.\nreference  생활코딩. 본격적으로 시작하기 전에 데이터베이스의 목적 강의를 보고 오는 것도 좋습니다.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n MySQL docs\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n   ","description":"","id":15,"section":"docs","tags":["mysql","db","config"],"title":"(1) : Install and Start Server","uri":"https://lyra95.github.io/docs/mysqltutorial/mysql-1/"},{"content":"전체코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  #main.py from flask import Flask from flask_restful import Api, Resource, reqparse, abort from flask_caching import Cache import time app = Flask(__name__) api = Api(app) config = { \u0026#34;DEBUG\u0026#34;: True, # some Flask specific configs \u0026#34;CACHE_TYPE\u0026#34;: \u0026#34;SimpleCache\u0026#34;, # Flask-Caching related configs \u0026#34;CACHE_DEFAULT_TIMEOUT\u0026#34;: 300 } app.config.from_mapping(config) # 데이터가 저장되는 곳 videos = { 1:{\u0026#39;name\u0026#39;:\u0026#39;HelloWorld\u0026#39;, \u0026#39;views\u0026#39;:147, \u0026#39;likes\u0026#39;:3} } # cache initialize cache = Cache(app) # request parser videos_put_args = reqparse.RequestParser() videos_put_args.add_argument(\u0026#34;name\u0026#34;,type=str, help=\u0026#39;Name of the video\u0026#39;,required=True) videos_put_args.add_argument(\u0026#34;views\u0026#34;,type=int, help=\u0026#39;Views of the video\u0026#39;,required=True) videos_put_args.add_argument(\u0026#34;likes\u0026#34;,type=int, help=\u0026#39;Likes of the video\u0026#39;,required=True) # exception handling def abort_video_not_exist(video_id): if video_id not in videos: abort(404,message=\u0026#34;video doesn\u0026#39;t exist\u0026#34;) class Video(Resource): @cache.cached(key_prefix=\u0026#39;get%s\u0026#39;) def get(self,video_id): #to see if cache work time.sleep(1) #to see how cache works #for k in cache.cache._cache: # print(k,cache.get(k)) abort_video_not_exist(video_id) return videos[video_id], 200 def put(self,video_id): args = videos_put_args.parse_args() videos[video_id] = args cache.delete(f\u0026#39;get/videos/{video_id}\u0026#39;) return videos[video_id], 201 def delete(self,video_id): abort_video_not_exist(video_id) del videos[video_id] cache.delete(f\u0026#39;get/videos/{video_id}\u0026#39;) return {}, 204 api.add_resource(Video,\u0026#34;/videos/\u0026lt;int:video_id\u0026gt;\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: app.run(debug=True)   import reqparse, abort, Cache를 추가로 import한다. cache가 실제로 동작하는지 확인하기 위해 time도 import했다.\n1 2 3 4  from flask import Flask from flask_restful import Api, Resource, reqparse, abort from flask_caching import Cache import time   abort는 *예외상황(get을 했을 때 해당하는 데이터가 없는 경우 등)*을 핸들링하기 위해 썼다.\nreqparse는 클라이언트의 requset uri를 파싱하기 위한 용도다. 예를 들어서, 클라이언트가 2:{'name':'ByeWorld', 'views':11, 'likes':2}와 같은 데이터를 put을 이용해 서버에 저장한다고 하면,\nput http://127.0.0.1:5000/videos/2?name=ByeWorld\u0026amp;views=11\u0026amp;likes=2라는 형태로 서버에 요청하게 된다. reqparse는 이 URI를 파싱해서 각각 필드에(name,views,likes) 값을 기록해준다.\ncache initialization 다음과 같이 configuration을 하고 cache를 이니셜라이즈한다.\n1 2 3 4 5 6 7 8 9 10 11 12  app = Flask(__name__) api = Api(app) config = { \u0026#34;DEBUG\u0026#34;: True, # some Flask specific configs \u0026#34;CACHE_TYPE\u0026#34;: \u0026#34;SimpleCache\u0026#34;, # Flask-Caching related configs \u0026#34;CACHE_DEFAULT_TIMEOUT\u0026#34;: 300 } app.config.from_mapping(config) # cache initialize cache = Cache(app)   SimpleCache는 flask_caching에서 제공하는 가장 기본적인 형태의 캐시다. 다른 여러가지 캐시들이 있으며, 사용자가 직접 만들수도 있다.\n 자세한 것은 https://flask-caching.readthedocs.io/en/latest/#built-in-cache-backends참고.\n cache의 기본적인 api는 차차 설명할테지만 docs을 참고하자.\n https://flask-caching.readthedocs.io/en/latest/api.html#cache-api\n 예외상황 핸들링 해당하는 video_id의 video가 없는데 get을 하라거나, 이미 video_id에 video가 저장되어있는데 put을 통해 새로운 video를 같은 video_id에 저장하려고하면 이상할 것이다.\n1 2 3 4  # exception handling def abort_video_not_exist(video_id): if video_id not in videos: abort(404,message=\u0026#34;video doesn\u0026#39;t exist\u0026#34;)   Restful api 아키텍처에서는 예외상황에 대한 리턴값으로 몇가지 정해진 약속이 있다. 없는 데이터를 반환하는 요청에 대해서는 404 에러코드를 리턴하도록 한다.\nrequest parser put을 위한 request parser 객체를 생성하고, field들을 추가해준다. field 이름, 타입, 헬프메시지(옵션), required 순이다. required=True로 설정함으로써, 모든 필드값이 주어진 요청만 valid하게 설정했다.\n1 2 3 4 5  # request parser videos_put_args = reqparse.RequestParser() videos_put_args.add_argument(\u0026#34;name\u0026#34;,type=str, help=\u0026#39;Name of the video\u0026#39;,required=True) videos_put_args.add_argument(\u0026#34;views\u0026#34;,type=int, help=\u0026#39;Views of the video\u0026#39;,required=True) videos_put_args.add_argument(\u0026#34;likes\u0026#34;,type=int, help=\u0026#39;Likes of the video\u0026#39;,required=True)   이제 다음과 같이 파서를 활용할 수 있다.\n1 2 3 4 5 6 7 8 9  class Video(Resource): #중략 def put(self,video_id): args = videos_put_args.parse_args() videos[video_id] = args cache.delete(f\u0026#39;get/videos/{video_id}\u0026#39;) return videos[video_id], 201   put http://127.0.0.1:5000/videos/2?name=ByeWorld\u0026amp;views=11\u0026amp;likes=2과 같은 요청이 들어왔다면 args = {'name':'ByeWorld', 'views':11, 'likes':2}가 될 것이다. 201 코드는 created라는 의미로, put 요청이 성공했다는 의사전달을 위해 리턴된다.\n테스트 다음과 같이 put/get 요청을 테스트해볼 수 있다.\n1 2 3 4 5 6 7 8 9  #test.py import requests BASE = \u0026#34;http://127.0.0.1:5000/\u0026#34; response = requests.put(BASE + \u0026#34;videos/2\u0026#34;,{\u0026#39;name\u0026#39;:\u0026#39;ByeWorld\u0026#39;, \u0026#39;views\u0026#39;:11, \u0026#39;likes\u0026#39;:2}) print(response.json()) response = requests.get(BASE + \u0026#34;videos/2\u0026#34;) print(response.json())   1 2 3  PS C:\\dev\\flask-rest-api-tuto\u0026gt; python test.py {\u0026#39;name\u0026#39;: \u0026#39;ByeWorld\u0026#39;, \u0026#39;views\u0026#39;: 11, \u0026#39;likes\u0026#39;: 2} [{\u0026#39;name\u0026#39;: \u0026#39;ByeWorld\u0026#39;, \u0026#39;views\u0026#39;: 11, \u0026#39;likes\u0026#39;: 2}]   다음 포스트에서는 cache에 대해 설명하겠다.\nReference  https://flask-caching.readthedocs.io/en/latest Python REST API Tutorial - Building a Flask REST API  ","description":"","id":16,"section":"docs","tags":["python","flask","rest api"],"title":"Flask로 Restful Api (2): reqparse로 요청 파싱하기","uri":"https://lyra95.github.io/docs/flask/rest-api-2/"},{"content":"__name__은 모듈 이름을 나타낸다. main 모듈일 경우 모듈이름은 main이된다.\n자세히 알아보기 위해 main.py랑 hello.py가 다음과 같이 있다 치자.\n1 2 3 4  #hello.py def foo(): print(\u0026#34;hello.py : \u0026#34; + __name__) foo()   1 2 3 4  #main.py import \u0026#34;hello.py\u0026#34; print(\u0026#34;main.py : \u0026#34; + __name__)   main.py를 실행하면 다음과 같다.\n1 2 3  PS C:\\dev\\ml\u0026gt; \u0026amp; \u0026#34;C:/Program Files/Python39/python.exe\u0026#34; c:/dev/ml/main.py hello.py : hello main.py : __main__   hello.py를 실행하면 다음과 같다.\n1 2  PS C:\\dev\\ml\u0026gt; \u0026amp; \u0026#34;C:/Program Files/Python39/python.exe\u0026#34; c:/dev/ml/hello.py hello.py : __main__   C++에서는 모듈 한 곳을 정해서 main 함수를 정의해야한다. 그리고 그 main함수가 프로그램의 엔트리 포인트가 된다.\n근데 python에서는 main함수가 딱히 정의 안 되어있어도 된다. 그냥 실행한 모듈이 main모듈이 되는 것이다.\n그래서 if __name__ == '__main__':의 정체는 바로, \u0026ldquo;해당 모듈이 main일 경우에~\u0026rdquo; 라는 의미다.\n","description":"","id":17,"section":"docs","tags":["syntax","python"],"title":"if __name__ == '__main__': 이 뭘까","uri":"https://lyra95.github.io/docs/python/python2/"},{"content":"AWS의 GPU instance 가격정책이 너무 비싼듯하여 google cloud를 시도하는데, (aws: 아무튼 비쌈/google: t4 tesla 0.35usd/hour)\nseoul region에는 gpu instace 서비스가 안되고 iowa region을 골랐더니 instance 이니셜라이제이션이 안되고 있다\u0026hellip;\n좀 더 알아본 후 상세히 포스팅하겠음.\n","description":"","id":18,"section":"docs","tags":["setting","pytorch","cuda","ml","machine learning","cloud"],"title":"Pytorch Install (Cloud) (draft)","uri":"https://lyra95.github.io/docs/ml/install-cloud.md/"},{"content":"기존 유저로 새 유저 생성 가이드 참고.\nrsa key pair는 이미 생성해서 4.번부터(sudo adduser {유저이름}) 6.b(chmod 600 .ssh\\authorized_keys) 까지 따라했다.\nsudo adduser newuser sudo su - newuser mkdir .ssh key pair(for new user)의 public key를 ec2 서버에 추가하기 key pair를 안 만들었다면 openSSH든 putty든 아마존에서 create key pair를 하든 아무튼 생성한다.\n ssh-keygen -y -f /path_to_key_pair/key-pair-name.pem로 public key를 얻는다. 대충 다음과 같이 생겼을 것이다. 복사를 한다.\n1  ssh-rsa aaaaaaaasdfjlsjadfl;ajf;asdjf어쩌고저쩌고asdjflas   ec2 서버에 접속해서 새 계정의 홈 디렉토리로 가서, 윗 단계에서 생성한 .ssh/authorized_keys에 붙여넣기 한다.\n cat \u0026gt;\u0026gt; .ssh\\authorized_keys 명령어든 뭐든 쓰삼\n plus alpha 방금 만든 새로운 계정을 ipad의 termius app에서 접속 가능하게 하고 싶었다.\ntermius app에서 rsa key를 생성하고 퍼블릭 키를 gmail로 보내서 데스크탑에서 복사한다.\n데스크탑에서 ec2 서버에 접속한 후, 위에서 처럼 authorized_keys에 퍼블릭키를 추가해주면 된다.\n시큐리티 그룹 설정에 맞으면 아이패드에서도 접속할 수 있다.\n 본인은 집 라우터 ip를 시큐리티 그룹 ssh 연결로 설정해둬서 집 와이파이로 연결했을때만 들어가진다.\n ","description":"","id":19,"section":"docs","tags":["aws","ec2","server"],"title":"aws EC2 server ADD USER","uri":"https://lyra95.github.io/docs/aws/ec2-2/"},{"content":"블로그 포스팅을 할 때 hugo new {path}/{namd}.md 같은 식으로 .md파일을 생성하는데, path가 점점 길어지다 보니 타이핑이 귀찮아져서 .ps1파일을 하나 생성했다.\n기본적인 if, switch문을 활용했다.\nif MS docs\nswitch MS docs\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  // post.ps1 $folder=$args[0] $name=$args[1] $path=\u0026#34;\u0026#34; switch ($folder) { \u0026#34;go\u0026#34; { $path=\u0026#34;content/ko/docs/go/\u0026#34; } \u0026#34;graphics\u0026#34; { $path=\u0026#34;content/ko/docs/graphics/\u0026#34; } Default { \u0026#34;Nothing is happened\u0026#34; } } if ( $path -ne \u0026#34;\u0026#34; ) { hugo new $path$name.md } else { \u0026#34;Nothing is happened\u0026#34; }    variable은 기본적으로 ${name}의 형식이다. $args로 사용자가 입력한 argument를 가져올 수 있다. !=이 아니라 -ne을 쓴다.  생각해보니 굳이 switch문을 쓸 필요는 없었다.\n1 2 3 4 5  // post.ps1 $folder=$args[0] $name=$args[1] $path=\u0026#39;content/ko/docs/\u0026#39; hugo new $path$folder/$name.md   이제 터미널에 ./post {dir} {name}만 입력해도 된다. ./post go new 이런 식으로.\n","description":"","id":20,"section":"docs","tags":["powershell","ps1"],"title":"Powershell 기본 문법","uri":"https://lyra95.github.io/docs/powershell/powershell-1/"},{"content":"이전 포스트를 참고하여 mysql을 실행합니다.생활코딩에서 MySQL의 전체적인 구조를 보고오면 이해에 도움이 될 것 입니다.\nDatabase 목록 보기 현재 database 목록을 보기 위해 SHOW DATABASES; 커맨드를 입력합니다.\n1 2 3 4 5 6 7 8 9 10 11 12  mysql\u0026gt;SHOWDATABASES;+--------------------+ |Database|+--------------------+ |information_schema||mysql||performance_schema||sys|+--------------------+ 4rowsinset(0.01sec)mysql\u0026gt;    mysql 명령문은 case sensetive하지 않습니다. show databases;를 입력하더라도 같은 결과를 보여줄 것입니다. 하지만 convention에 따라, 사용자가 지정한 이름은 소문자로, 그외는 대문자로 써서 알아보기 편하게 합시다.\n  sql 명령문의 마지막은 ;로 끝납니다. ;로 끝내기 전에 enter를 입력해서, 명령문을 여러줄 입력할 수 있습니다.\n  Create Database CREATE DATABASE {database_name}; 커맨드를 입력해 database를 생성합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  mysql\u0026gt;CREATEDATABASEtutorial;QueryOK,1rowaffected(0.01sec)mysql\u0026gt;SHOWDATABASES;+--------------------+ |Database|+--------------------+ |information_schema||mysql||performance_schema||sys||tutorial|+--------------------+ 5rowsinset(0.00sec)mysql\u0026gt;   tutorial은 사용자가 지정한 이름이므로 convention에 따라 소문자로 입력했습니다.\n tutorial이라는 이름의 database를 생성했습니다.\nDelete Database DROP DATABASE {database_name}; 커맨드를 입력해 database를 삭제할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  mysql\u0026gt;DROPDATABASEtutorial;QueryOK,0rowsaffected(0.01sec)mysql\u0026gt;SHOWDATABASES;+--------------------+ |Database|+--------------------+ |information_schema||mysql||performance_schema||sys|+--------------------+ 4rowsinset(0.00sec)mysql\u0026gt;  tutorial database로 접속 tutorial database를 다시 생성합니다.\nUSE {database_name}; 커맨드를 입력하여 tutorial database로 접속할 수 있습니다.\n1 2 3 4 5 6  mysql\u0026gt;CREATEDATABASEtutorial;QueryOK,1rowaffected(0.01sec)mysql\u0026gt;USEtutorial;Databasechangedmysql\u0026gt;  ","description":"","id":21,"section":"docs","tags":["mysql","db","tutorial"],"title":"(2) : Tutorial","uri":"https://lyra95.github.io/docs/mysqltutorial/mysql-2/"},{"content":"Error Description vscode 19\nwindows 10 64bit\nbuild 시 다음과 같은 에러메세지\n1 2 3 4 5 6 7 8 9  Starting build... cl.exe /Zi /EHsc /nologo /Fe: C:\\dev\\codejam\\strikeBall.exe C:\\dev\\codejam\\strikeBall.cpp \u0026#39;cl.exe\u0026#39; is not recognized as an internal or external command, operable program or batch file. Build finished with error(s). The terminal process failed to launch (exit code: -1). Terminal will be reused by tasks, press any key to close it.   tasks.json\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  { \u0026#34;version\u0026#34;: \u0026#34;2.0.0\u0026#34;, \u0026#34;tasks\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;cppbuild\u0026#34;, \u0026#34;label\u0026#34;: \u0026#34;C/C++: cl.exe build active file\u0026#34;, \u0026#34;command\u0026#34;: \u0026#34;cl.exe\u0026#34;, \u0026#34;args\u0026#34;: [ \u0026#34;/Zi\u0026#34;, \u0026#34;/EHsc\u0026#34;, \u0026#34;/nologo\u0026#34;, \u0026#34;/Fe:\u0026#34;, \u0026#34;${fileDirname}\\\\${fileBasenameNoExtension}.exe\u0026#34;, \u0026#34;${file}\u0026#34; ], \u0026#34;options\u0026#34;: { \u0026#34;cwd\u0026#34;: \u0026#34;${workspaceFolder}\u0026#34; }, \u0026#34;problemMatcher\u0026#34;: [ \u0026#34;$msCompile\u0026#34; ], \u0026#34;group\u0026#34;: { \u0026#34;kind\u0026#34;: \u0026#34;build\u0026#34;, \u0026#34;isDefault\u0026#34;: true }, \u0026#34;detail\u0026#34;: \u0026#34;compiler: cl.exe\u0026#34; } ] }   Intellisense c++ configuration(UI)\nSolution Intellisense c++ configuration의 compiler path가 맞는지 확인하자.\ntasks.json에서 command \u0026ldquo;cl.exe\u0026quot;를 실제 cl.exe의 path로 바꾸거나, 환경변수에 cl.exe path를 추가해보자.\n그래도 해결이 안 된다면(필자와 같은 경우) 링크 참고\nDear People from the future looking to solve your issue: Here is what we have figured out so far: In case you get the error C1034: iostream: no include path set: If you haven't already, start VS code from the Developer Command Prompt that is installed with the MSVC compiler set. If you have everything resolved now, very good. If not, continue. In case you get the error fatal error LNK1112: module machine type 'x86' conflicts with target machine type 'x64', you need to start VS Code from the x64 Developer Command Prompt  Developer Command Prompt에서 project directory로 들어가서 code . command를 통해 vs code를 실행하자. 이후 build시 cl.exe is not recognized 에러가 해결됬다.\nPS:Another ERROR 1 2 3  helloworld.cpp c:\\Users\\nicta\\dev\\c++\\helloworld\\helloworld.cpp(1): fatal error C1034: iostream: no include path set The terminal process terminated with exit code: 2   build 시 위와 같이 standard library header가 include 되지 않고 C1034 에러코드가 나는 경우,\nintellisense c/c++ configuration에서 include path를 확인해보자.\n필자의 경우 standard library header file들이 C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\VC\\Tools\\MSVC\\14.28.29910\\include 경로에 있었는데, configuration에 path가 추가가 안 되어 있어서 추가해줬다.\n","description":"","id":22,"section":"docs","tags":["c++","cl.exe","vscode","config"],"title":"VScode 'cl.exe' is not recognized error","uri":"https://lyra95.github.io/docs/configurations/cl-exe-setting/"},{"content":"전체코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63  #main.py from flask import Flask from flask_restful import Api, Resource, reqparse, abort from flask_caching import Cache import time app = Flask(__name__) api = Api(app) config = { \u0026#34;DEBUG\u0026#34;: True, # some Flask specific configs \u0026#34;CACHE_TYPE\u0026#34;: \u0026#34;SimpleCache\u0026#34;, # Flask-Caching related configs \u0026#34;CACHE_DEFAULT_TIMEOUT\u0026#34;: 300 } app.config.from_mapping(config) # 데이터가 저장되는 곳 videos = { 1:{\u0026#39;name\u0026#39;:\u0026#39;HelloWorld\u0026#39;, \u0026#39;views\u0026#39;:147, \u0026#39;likes\u0026#39;:3} } # cache initialize cache = Cache(app) # request parser videos_put_args = reqparse.RequestParser() videos_put_args.add_argument(\u0026#34;name\u0026#34;,type=str, help=\u0026#39;Name of the video\u0026#39;,required=True) videos_put_args.add_argument(\u0026#34;views\u0026#34;,type=int, help=\u0026#39;Views of the video\u0026#39;,required=True) videos_put_args.add_argument(\u0026#34;likes\u0026#34;,type=int, help=\u0026#39;Likes of the video\u0026#39;,required=True) # exception handling def abort_video_not_exist(video_id): if video_id not in videos: abort(404,message=\u0026#34;video doesn\u0026#39;t exist\u0026#34;) class Video(Resource): @cache.cached(key_prefix=\u0026#39;get%s\u0026#39;) def get(self,video_id): #to see if cache work time.sleep(1) #to see how cache works #for k in cache.cache._cache: # print(k,cache.get(k)) abort_video_not_exist(video_id) return videos[video_id], 200 def put(self,video_id): args = videos_put_args.parse_args() videos[video_id] = args cache.delete(f\u0026#39;get/videos/{video_id}\u0026#39;) return videos[video_id], 201 def delete(self,video_id): abort_video_not_exist(video_id) del videos[video_id] cache.delete(f\u0026#39;get/videos/{video_id}\u0026#39;) return {}, 204 api.add_resource(Video,\u0026#34;/videos/\u0026lt;int:video_id\u0026gt;\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: app.run(debug=True)   캐시에 대해서 캐시는 언제 적용되야할까?\n서버에 get videos/1 요청이 오고, 바로 또 get videos/1 요청이 오면 같은 연산을 서버가 반복하는 것보다 캐시에 저장된 값을 리턴하는게 좋을 것이다.\n근데 캐시를 쓰지 않거나 캐시가 지워져야 하는 상황들이 있다. 일반적으로 put/delete에 대해서는 캐시를 쓰지 않는 것이 원칙이고, post에 대해서도 제한적으로 활용한다.\n https://restfulapi.net/caching/\n 서버에 get videos/1 요청이 와서 캐시에 결과를 저장해 뒀더니, 누가 delete videos/1 요청을 했다고하자. 그럼 캐시도 당연히 없어져야 맞을 것이다. (누가 get 요청을 했을 때 없는 데이터를 있다고 반환하면 안되니까)\n이러한 상황들을 머리에 두고 캐시를 활용하자.\n캐시 API cache의 기본적인 api는 차차 설명할테지만 docs을 참고하자.\n https://flask-caching.readthedocs.io/en/latest/api.html#cache-api\n 캐시를 사용할 함수에 데코레이터[wikidocs]](https://wikidocs.net/23106)로 적용한다.\n만일 다른 데코레이터들도 있다면 데코레이터들 간 순서가 중요하다.Caching View Functions Warning 참고\n1 2 3 4 5 6 7 8 9 10 11 12  class Video(Resource): @cache.cached(key_prefix=\u0026#39;get%s\u0026#39;) def get(self,video_id): #to see if cache work time.sleep(1) #to see how cache works #for k in cache.cache._cache: # print(k,cache.get(k)) abort_video_not_exist(video_id) return videos[video_id],   연산 결과 값은 캐시에 딕셔너리처럼 저장된다. 클라이언트로부터 get http://127.0.0.1:5000/videos/1 같은 요청이 들어왔다고 치자. 그러면 캐시에서 view//vidoes/1이라는 스트링 키에 연산결과가 저장된다.(key_prefix를 설정하지 않은 경우)\n위와 같이 key_prefix를 설정한 경우, 키값은 gets/videos/1이 된다. %s는 videos/1과 정확히 대응된다.\n키값을 확인하고 싶으면 주석 처리된 부분을 활용해보자.( _cache에서 알 수 있듯, 개발자가 의도한 public api는 아니다.)\n아까 말했듯, delete나 put을 할 때 get의 캐시도 지워줘야 한다. cache.delete(키)를 활용해 지울 수 있다.\n1 2 3 4 5  def delete(self,video_id): abort_video_not_exist(video_id) del videos[video_id] cache.delete(f\u0026#39;get/videos/{video_id}\u0026#39;) return {}, 204   참고로 \u0026ldquo;CACHE_DEFAULT_TIMEOUT\u0026rdquo;: 300로 설정했으므로 300초가 지나면 캐시는 자동으로 지워진다. @cache.cached(key_prefix=\u0026lsquo;get%s\u0026rsquo;,timeout=50)과 같이 개별적으로 시간을 달리 적용할 수도 있다.\n테스트 크롬, 파폭 확장 어플리케이션을 이용하는 게 편할 것이다.\n캐시가 있으면 get이 1초가 걸리지 않는다. 캐시가 없으면 get 요청이 1초 이상 걸린다.\nget-put-get, get-delete-get 등등 캐시가 올바르게 동작하는지 확인하자.\nPS: memoize() cached()말고도 비슷하게 동작하는 memoize()가 있다. 함수의 파라미터에 넣어진 값 별로 캐시를 하고 싶을 때 쓰는 듯하다.\n위의 코드에서 cached대신에 memoize를 쓰려고하면 문제가 발생한다: self도 파라미터라서, 같은 video_id에 대한 요청인데도 불구하고 다른 인스턴스(self)로 취급하고 사실상 캐시가 안 된다.\nflask-cache-memoize-not-working-with-flask-restful-resources 이렇게 customizing을 통해 첫번째 파라미터(self)를 무시하게 하는 방법으로 해결할 수 있다고 한다.\n딱히 지금 필요한 함수도 아니라서 안 쓴다.\nReference  https://flask-caching.readthedocs.io/en/latest What is Rest What does key_prefix do for flask-cache?  ","description":"","id":23,"section":"docs","tags":["python","flask","rest api"],"title":"Flask로 Restful Api (3): 캐시 설정하기","uri":"https://lyra95.github.io/docs/flask/rest-api-3/"},{"content":"param([switch] $help )를 이용해서 if-else로 처리한다.\n1 2 3 4 5 6 7 8 9 10 11 12  param([switch] $help ) if ($help) { Write-Host \u0026#34;create new md file:\u0026#34; write-host \u0026#34;./post {category} {name}\u0026#34; } else { $folder=$args[0] $name=$args[1] $path=\u0026#39;content/ko/docs/\u0026#39; hugo new $path$folder/$name.md }   -h 나 -help flag를 주면된다.\n1 2 3 4  PS C:\\dev\\blog\u0026gt; ./post -h create new md file: ./post {category} {name}   ","description":"","id":24,"section":"docs","tags":["powershell","help"],"title":"Help 메시지 출력하게 하기","uri":"https://lyra95.github.io/docs/powershell/help/"},{"content":"*args는 파라미터를 여러개(정해지지 않은 갯수)로 받을 때 쓴다.\n굳이 이름이 args일 필요는 없다. *Namelist 이렇게 써도 된다.\n타입을 출력해보면 args는 tuple임을 알 수 있다.\n**kwargs도 파라미터를 여러개(정해지지 않은 갯수)로 받을 때 쓴다. 차이점은 dict형태로 받는다는 것이다.\n얘도 굳이 이름이 kwargs일 필요는 없다.\n1 2 3 4 5 6 7 8 9 10 11  def fo(*names): print(type(names),names) for n in names: print(n) def foo(**names): print(type(names),names) for k,v in names.items(): print(k,v) fo(\u0026#34;a\u0026#34;,1,True) foo(a=1,b=True,c=\u0026#34;c\u0026#34;)   1 2 3 4 5 6 7 8  \u0026lt;class \u0026#39;tuple\u0026#39;\u0026gt; (\u0026#39;a\u0026#39;, 1, True) a 1 True \u0026lt;class \u0026#39;dict\u0026#39;\u0026gt; {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: True, \u0026#39;c\u0026#39;: \u0026#39;c\u0026#39;} a 1 b True c c   ","description":"","id":25,"section":"docs","tags":["syntax","python"],"title":"*args와 **kwargs","uri":"https://lyra95.github.io/docs/python/python3/"},{"content":"pytorch 튜토리얼 코스를 참고했다.\n전체 코드 링크를 새탭에서 열고 ctr+s해서 저장가능.\n주피터 노트북 파일(.ipynb)\ndevice 선택 gpu/cpu 먼저 cpu와 gpu중 device를 선택한다. gpu가 있고 cuda가 설치되어 있으면 cuda를 사용하고, 아니면 cpu를 사용한다.\n1 2 3  import torch device = \u0026#39;cuda\u0026#39; if torch.cuda.is_available() else \u0026#39;cpu\u0026#39; #print(\u0026#39;Using {} device\u0026#39;.format(device)) 로 device 확인가능   MNIST 데이터 가져오기 본디 MNIST는 28*28 사이즈의 흑백으로된 0~9 숫자 손글씨 이미지 데이터다. 근데 지금와서는 일종의 프로토콜처럼 사용되고 있다.\nFashionMNIST는 28*28 사이즈, 흑백, 10 종류의 의상 이미지 데이터이다. 다음 코드로 데이터를 {프로젝트최상위}/data에 설치할 수 있다.\n1 2 3 4 5 6  from torch.utils.data import Dataset from torchvision import datasets from torchvision.transforms import ToTensor training_data = datasets.FashionMNIST(root=\u0026#34;data\u0026#34;, train=True,download=True,transform=ToTensor()) test_data = datasets.FashionMNIST(root=\u0026#34;data\u0026#34;, train=False,download=True,transform=ToTensor())    root 파라미터에 설치 경로를 주면된다. train 파라미터로 트레이닝에 쓸 데이터인지 아닌지 정할 수 있다. 해당 경로에 데이터가 없으므로 download=True로 받아올 수 있다. ToTensor()는 PIL이미지나 np.array를 Tensor로 바꾸어준다.   train=False로 하게되면, gradient값을 계산/저장할 필요가 없어서 성능이 향상된다.\ngredient 부분에 대해서 Autograd 간단히 살펴보기를 참고. 중간 난이도 설명, 어려운 설명\n FashionMNIST말고도 다양한 데이터들이 미리 준비되어 있다. 일본어 고대 히라가나 글씨 데이터 같은 KMNIST도 있다. 마찬가지로 datasets.KMNIST(...)로 데이터를 받아올 수 있다.\n만약 자신만의 데이터셋을 쓰고 싶으면 class CustomDataset(Dateset)과 같이 클래스를 만들고, __init__, __len__, __getitem__을 구현하면 된다. 링크: Creating a Custom Dataset for your files참고.\n(optional) matplotlib으로 데이터 가시화해보기 다음 코드로 전체 데이터 중에 rows*cols=9개 만큼의 데이터를 가져와서 이미지를 볼 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  import matplotlib.pyplot as plt labels_map = { 0: \u0026#34;T-Shirt\u0026#34;, 1: \u0026#34;Trouser\u0026#34;, 2: \u0026#34;Pullover\u0026#34;, 3: \u0026#34;Dress\u0026#34;, 4: \u0026#34;Coat\u0026#34;, 5: \u0026#34;Sandal\u0026#34;, 6: \u0026#34;Shirt\u0026#34;, 7: \u0026#34;Sneaker\u0026#34;, 8: \u0026#34;Bag\u0026#34;, 9: \u0026#34;Ankle Boot\u0026#34;, } figure = plt.figure(figsize=(8, 8)) cols, rows = 3, 3 for i in range(1, cols * rows + 1): sample_idx = torch.randint(len(training_data), size=(1,)).item() img, label = training_data[sample_idx] figure.add_subplot(rows, cols, i) plt.title(labels_map[label]) plt.axis(\u0026#34;off\u0026#34;) plt.imshow(img.squeeze(), cmap=\u0026#34;gray\u0026#34;) plt.show()   이 글의 목표는 matplotlib 사용법을 공부하려는 것이 아니다. training_data[index]로 index번째 데이터를 가져올 수 있다는 것에 주목하자.\n데이터 로딩하기 1 2 3 4  from torch.utils.data import DataLoader train_dataloader = DataLoader(training_data, batch_size=64, shuffle=True) test_dataloader = DataLoader(test_data, batch_size=64, shuffle=True)    batch_size는 한 번에 올라가는 데이터의 개수다. 즉 (텐서로 변환된) 이미지 파일이 한 번에 batch_size=64개 씩 device로 올라간다. shuffle=True로 두면 데이터의 순서가 랜덤해진다. overfitting을 완화하기 위해 보통 True로 둔다.   gpu는 병렬연산에 특화되어있어서, 한 번에 많이 올릴 수 있으면 모델 트레이닝이 빨라진다. 대신 트레이닝 시, 모델 파라미터 업데이트 횟수가 그만큼 줄어든다.(전체 데이터 수/batch_size 번)\n (optional) train_dataloader iterator화 iter(train_dataloader)로 iterator화 할 수 있다. train_dataloader의 첫번째에 어떤게 들어있는지 보자.\n1 2 3  iterator = iter(train_dataloader) first = next(iterator) print(first)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21  [tensor([[[[0.0000, 0.0000, 0.0000, ..., 0.0000, 0.0000, 0.0000], [0.0000, 0.0000, 0.0000, ..., 0.0000, 0.0000, 0.0000], [0.0000, 0.0000, 0.0000, ..., 0.0000, 0.0000, 0.0000], ..., [0.0000, 0.0000, 0.0000, ..., 0.0000, 0.0000, 0.0000], [0.0000, 0.0000, 0.0000, ..., 0.0000, 0.0000, 0.0000], [0.0000, 0.0000, 0.0000, ..., 0.0000, 0.0000, 0.0000]]], ..., [[[0.0000, 0.0000, 0.0000, ..., 0.0000, 0.0000, 0.0000], [0.0000, 0.0000, 0.0000, ..., 0.0000, 0.0000, 0.0000], [0.0000, 0.0000, 0.4353, ..., 0.5686, 0.0000, 0.0000], ..., [0.0000, 0.0000, 0.1176, ..., 0.1333, 0.0000, 0.0000], [0.0000, 0.0000, 0.0000, ..., 0.0000, 0.0157, 0.0000], [0.0000, 0.0000, 0.0000, ..., 0.0000, 0.0000, 0.0000]]]]), tensor([7, 2, 8, 6, 0, 8, 9, 2, 0, 9, 1, 5, 9, 8, 1, 6, 3, 0, 6, 4, 6, 2, 4, 2, 9, 4, 0, 6, 3, 0, 1, 4, 2, 2, 2, 8, 7, 3, 5, 1, 4, 8, 5, 6, 1, 4, 1, 6, 4, 2, 3, 0, 9, 7, 6, 3, 2, 2, 2, 6, 9, 8, 1, 8]) ]   잘 모르겠지만 first에 텐서가 2개 들어있다. 다음 결과를 보면 2개의 정체가 뭔지 알 수 있다.\n1 2  imgs, labels = first print(imgs.shape, labels.shape)   1  torch.Size([64, 1, 28, 28]) torch.Size([64])   batch_size=64와 이미지 파일이 흑백 28*28 픽셀이었다는 것을 상기하자. imgs는 batch_size개수만큼의 데이터, labels는 각각 데이터의 레이블이다.\n실제로 그림을 그려서 확인해볼수 있다.\n1 2 3 4 5 6 7 8 9 10  import matplotlib.pyplot as plt # Display image and label. train_features, train_labels = next(iter(train_dataloader)) print(f\u0026#34;Feature batch shape: {train_features.size()}\u0026#34;) print(f\u0026#34;Labels batch shape: {train_labels.size()}\u0026#34;) img = train_features[0].squeeze() label = train_labels[0] plt.imshow(img, cmap=\u0026#34;gray\u0026#34;) plt.show() print(f\u0026#34;Label: {label.item()}\u0026#34;)   ","description":"","id":26,"section":"docs","tags":["pytorch","mnist"],"title":"Loading MNIST data : Pytorch tutorial (1)","uri":"https://lyra95.github.io/docs/ml/mnist/"},{"content":"먼저 vscode에서 remote - ssh 애드온을 설치한다.\n왼쪽 탭에 remote explore라고 새로운 탭이 생긴다. ssh targets에 아직 아무것도 없다.\n톱니바퀴를 눌러서 config파일을 눌러서 다음과 같이 내용을 수정했다.\n1 2 3 4 5  # Read more about SSH config files: https://linux.die.net/man/5/ssh_config Host {아무거나 display할 이름} HostName {ec2 인스턴스의 dns나 ipv4} User ec2-user IdentityFile {key pair pem 파일 경로}   error: The process tried to write to a nonexistent pipe config 파일 경로가 c:\\users\\{유저이름}\\.ssh\\config 였는데, config파일을 복사해서 C:\\ProgramData\\ssh\\config로 옮겼다. 그리고나서 remote-ssh 애드온 셋팅에서 config 경로를 C:\\ProgramData\\ssh\\config로 바꿨더니 해결되었다.\n 유저이름이 한글로 되어있어서 생긴 문제인가 싶다. 윈도우즈는 유저이름 폴더를 바꿀 수단을 제공해주지 않아서 빡친다. (예전에 이름 바꾸려고 레지스트리 잘못건드리다가 포맷함.)\n ","description":"","id":27,"section":"docs","tags":["aws","vscode","ssh","setting"],"title":"vs code remote:ssh로 ec2 접속","uri":"https://lyra95.github.io/docs/aws/ec2-3/"},{"content":" 본 항목은 생활코딩을 참고하였습니다.\n CRUD란 Create, Read, Update, Delete의 앞글자만 따온 것으로, 데이터베이스의 기본 기능들입니다. sql이라는 언어가 이런 기능들을 어떤 문법으로 지원하는지 봅시다.\n이전 포스트에서 tutorial database에 접속했습니다.다음과 같은 정보들이 있다고 합시다:\n   id title description created author profile     1 MySQL MySQL is \u0026hellip; 2018-01-10 egoing developer   2 ORACLE Oracle is \u0026hellip; 2018-01-15 egoing developer   3 SQL Server SQL Server is \u0026hellip; 2018-01-18 duru database administrator   4 PostgreSQL PostgreSQL is \u0026hellip; 2018-01-20 taeho data scientist, developer   5 MongoDB MongoDB is \u0026hellip; 2018-01-30 egoing developer    이 정보들을 sql을 통해 데이터베이스에 저장하려고 합니다.\nCreate Table 다음 명령어를 통해 topic이라는 이름을 가진 table을 생성합니다.\n1 2 3 4 5 6 7 8 9  mysql\u0026gt;CREATETABLEtopic(-\u0026gt;idINT(11)NOTNULLAUTO_INCREMENT,-\u0026gt;titleVARCHAR(100)NOTNULL,-\u0026gt;descriptionTEXTNULL,-\u0026gt;createdDATETIMENOTNULL,-\u0026gt;authorVARCHAR(15)NULL,-\u0026gt;profileVARCHAR(200)NULL,-\u0026gt;PRIMARYKEY(id)-\u0026gt;);   id, title, \u0026hellip; 을 attribute(속성)으로 갖는 테이블을 생성하였습니다. INT, VARCHAR, TEXT, 등등은 해당 칸에 들어갈 데이터 타입을 의미합니다. NOT NULL, NULL 은 해당 칸에 앞으로 들어갈 데이터들이 NULL이 될 수 있는 지 정하는 명령어 입니다. NOT NULL일 경우 NULL 데이터가 올 수 없게 하겠다는 뜻 입니다. PRIMARY KEY(id)의 의미는 id attribute를 식별자로 쓰겠다는 의미 입니다. 앞으로 저장될 데이터들은 id 값과 일대일 대응이 됩니다. AUTO_INCREMENT 키워드의 의미는, 데이터가 차곡차곡 들어올 때마다 알아서 id 값을 1씩 키워주겠다는 의미입니다.   각 타입에 대한 자세한 설명은 MySQL docs을 확인하세요.\n  타입(숫자)에서 보통 숫자는 size를 의미합니다만, INT(11)의 경우에는 의미가 다릅니다: 검색해서 결과를 볼 때 11건까지만 보겠다는 의미입니다.\n 이만큼의 커맨드로 아래와 같은 테이블을 생성하는 일을 해낸 것 입니다:\n   id title description created author profile    SHOW TABLES; 커맨드를 입력해 현재 데이터베이스(=tutorial)에 있는 테이블 목록을 볼 수 있습니다.\n1 2 3 4 5 6 7 8 9  mysql\u0026gt;SHOWTABLES;+--------------------+ |Tables_in_tutorial|+--------------------+ |topic|+--------------------+ 1rowinset(0.01sec)mysql\u0026gt;  ADD RECORD (1) 다음 한 줄의 데이터를 추가해봅시다.\n   1 MySQL MySQL is \u0026hellip; 2018-01-10 egoing developer     이런 한 줄의 데이터를 Record라고 부릅니다.\n 레코드를 추가하기전에, topic 테이블의 attribute 타입이 어떻게 구성되어 있는 지 확인합시다.\n1 2 3 4 5 6 7 8 9 10 11 12  mysql\u0026gt;DESCtopic;+-------------+--------------+------+-----+---------+----------------+ |Field|Type|Null|Key|Default|Extra|+-------------+--------------+------+-----+---------+----------------+ |id|int|NO|PRI|NULL|auto_increment||title|varchar(100)|NO||NULL|||description|text|YES||NULL|||created|datetime|NO||NULL|||author|varchar(15)|YES||NULL|||profile|varchar(200)|YES||NULL||+-------------+--------------+------+-----+---------+----------------+ 6rowsinset(0.00sec)   보통의 경우 남이 생성한 테이블에 레코드를 추가할 일이 더 많으므로, 이렇게 타입을 확인하고 레코드를 추가해야합니다.\n 다음 커맨드로 레코드를 추가할 수 있습니다.\n1 2 3  mysql\u0026gt;INSERTINTOtopic(id,title,description,created,author,profile)-\u0026gt;VALUES(1,\u0026#39;MySQL\u0026#39;,\u0026#39;MySQL is ...\u0026#39;,\u0026#39;2018-01-10\u0026#39;,\u0026#39;egoing\u0026#39;,\u0026#39;developer\u0026#39;);QueryOK,1rowaffected(0.01sec)   엔터를 입력해서 보기 편하게 여러줄로 입력할 수 있습니다.\n 제대로 레코드가 추가되었는지 확인해 봅시다.\n1 2 3 4 5 6 7  mysql\u0026gt;SELECT*FROMtopic;+----+-------+--------------+---------------------+--------+-----------+ |id|title|description|created|author|profile|+----+-------+--------------+---------------------+--------+-----------+ |1|MySQL|MySQLis...|2018-01-1000:00:00|egoing|developer|+----+-------+--------------+---------------------+--------+-----------+ 1rowinset(0.00sec)  ADD Record (2) 일부의 attribute만 정해서 레코드를 추가할 수 있습니다.\n1 2 3  mysql\u0026gt;INSERTINTOtopic(title,created)-\u0026gt;VALUES(\u0026#39;ORACLE\u0026#39;,NOW());QueryOK,1rowaffected(0.01sec)  나머지 attribute에는 디폴트값으로 정해집니다.\n  NOT NULL이면서 NULL이 디폴트값인 attribute는 레코드를 추가할 때 디폴트가 들어가게 하면 안 됩니다.\n  id의 경우 AUTO_INCREMENT가 알아서 id값에 2를 부여해주었습니다.\n  NOW()는 현재 시간으로 정해주는 키워드입니다.\n  같은 방법으로 나머지 레코드들도 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt;SELECT*FROMtopic;+----+------------+--------------+---------------------+--------+-----------+ |id|title|description|created|author|profile|+----+------------+--------------+---------------------+--------+-----------+ |1|MySQL|MySQLis...|2018-01-1000:00:00|egoing|developer||2|ORACLE|NULL|2021-05-0618:17:04|NULL|NULL||3|SQLServer|NULL|2021-05-0618:27:09|NULL|NULL||4|PostgreSQL|NULL|2021-05-0618:27:24|NULL|NULL||5|MongoDB|NULL|2021-05-0618:27:43|NULL|NULL|+----+------------+--------------+---------------------+--------+-----------+ 5rowsinset(0.00sec)  Update Table ORACLE 레코드를 수정합니다.\n1 2 3 4 5 6  mysql\u0026gt;UPDATEtopicSETdescription=\u0026#39;Oracle is...\u0026#39;,-\u0026gt;author=\u0026#39;egoing\u0026#39;,-\u0026gt;profile=\u0026#39;developer\u0026#39;-\u0026gt;WHEREid=2;QueryOK,1rowaffected(0.01sec)Rowsmatched:1Changed:1Warnings:0   {attribute_name}={value} 형식입니다. WHERE 조건문을 통해 수정할 대상을 정할 수 있습니다.  수정이 제대로 됬는지 확인합니다.\n1 2 3 4 5 6 7  mysql\u0026gt;SELECT*FROMtopicWHEREid=2;+----+--------+--------------+---------------------+--------+-----------+ |id|title|description|created|author|profile|+----+--------+--------------+---------------------+--------+-----------+ |2|ORACLE|Oracleis...|2021-05-0618:17:04|egoing|developer|+----+--------+--------------+---------------------+--------+-----------+ 1rowinset(0.00sec)   SELECT의 자세한 설명은 다음 포스트에서 설명합니다.\n 나머지도 같은 방법으로 수정해 줍니다.\n","description":"","id":28,"section":"docs","tags":["mysql","db","crud"],"title":"(3) : CRUD commands","uri":"https://lyra95.github.io/docs/mysqltutorial/mysql-3/"},{"content":"Golang는 쉽고 간편한 테스트와 벤치마크를 제공합니다. 이 항목에서는 간단하게 소수판별 프로그램을 작성하며 golang의 테스트와 벤치마크를 사용해봅시다.\nTDD(Test-Driven-Deleopment, 테스트 주도 개발) 절차에 따라 코드를 작성해 봅시다.\n모듈 생성 프로젝트 디렉토리에서 터미널을 열고, go mod init {module 이름}을 입력합니다. 모듈이름은 prime으로 하겠습니다.\n1 2  PS C:\\dev\\goproject\\prime\u0026gt; go mod init prime go: creating new go.mod: module prime   go.mod 파일이 생성되었습니다.\ntest go 파일 생성/작성 test를 위한 go 파일은 이름이 _test.go로 끝나야 합니다. 프로젝트 디렉토리에 prime_test.go라는 파일을 생성하고 다음과 같이 작성합니다.\n1 2 3 4 5 6 7 8  // prime_test.go package main import \u0026#34;testing\u0026#34; func TestPrime1(t *testing.T) { }    Test{테스트이름}(t *testing.T) 형식을 지키면 됩니다. 테스트이름의 첫 글자는 대문자여야 합니다.  이제 TestPrime1 함수 안에 테스트할 코드를 입력하면 됩니다.\n하지만 아직 구체적으로 어떤 소수 판별 프로그램을 작성할지 정하지 않았군요. 대충 3가지가 떠오릅니다.\n   자연수 n을 입력받아서 n이 소수면 true 아니면 false를 리턴하는 프로그램    자연수 n을 입력받아서 1~n까지의 소수의 개수를 리턴하는 프로그램    자연수 n을 입력받아서 1~n까지의 소수의 리스트를 리턴하는 프로그램    어떤 걸로 할지는 여러분 마음대로입니다. 저는 2를 택하겠습니다. 그러면 이런식으로 테스트 코드를 작성하면 됩니다. (1~100까지 중에 소수가 25개가 있음을 참고)\n1 2 3 4 5 6  func TestPrime1(t *testing.T) { result := prime(100) if result != 25 { t.Errorf(\u0026#34;prime(100) should be 25 but prime(100) returns %d\u0026#34;, result) } }   테스트 실행 prime이 아직 정의가 안 됬습니다. prime.go 파일을 생성하고 다음과 같이 작성합시다.\n1 2 3 4 5 6  // prime.go package main func prime(n int) int { return 0 }   터미널에서 go test를 입력하여 test를 실행할 수 있습니다.\n1 2 3 4 5 6  PS C:\\dev\\goproject\\prime\u0026gt; go test --- FAIL: TestPrime1 (0.00s) prime_test.go:8: prime(100) should be 25 but prime(100) returns 0 FAIL exit status 1 FAIL prime 4.138s   당연히 테스트는 실패합니다.\nprime.go 코드 작성 이 글의 주된 목표는 테스트 활용이기 때문에, 이 부분은 그냥 복붙하시고 다음 장으로 넘어가도 좋습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // prime.go package main func isPrime(n int) bool { if n == 0 || n == 1 { return false } for d := 2; d*d \u0026lt;= n; d++ { if n%d == 0 { return false } } return true } func prime(n int) int { cnt := 0 for i := 1; i \u0026lt;= n; i++ { if isPrime(i) { cnt++ } } return cnt } func main() { }    효율성이 주된 논제가 아니므로, 가독성을 위해 에라토스테네스의 체 알고리즘은 사용하지 않았습니다.\n 테스트 실행 go test로 테스트를 해봅시다.\n1 2 3 4  PS C:\\dev\\goproject\\prime\u0026gt; go test PASS ok prime 4.891s PS C:\\dev\\goproject\\prime\u0026gt;   다음 포스트에서는 테스트 모듈에 대해 더 자세히 알아보겠습니다.\n더 읽어볼거리 자연수를 다루다 보니 uint를 쓸까(unsigned) 고민했었는데 링크를 참고해 보세요.\n","description":"","id":29,"section":"docs","tags":["golang","test","benchmark"],"title":"(1)-1 : golang test","uri":"https://lyra95.github.io/docs/go/go-test-1/"},{"content":"전체코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83  # main.py from flask import Flask, request from flask_restful import Api, Resource, reqparse, abort, fields, marshal_with from flask_caching import Cache from flask_sqlalchemy import SQLAlchemy import time app = Flask(__name__) api = Api(app) config = { \u0026#34;DEBUG\u0026#34;: True, # some Flask specific configs \u0026#34;CACHE_TYPE\u0026#34;: \u0026#34;SimpleCache\u0026#34;, # Flask-Caching related configs \u0026#34;CACHE_DEFAULT_TIMEOUT\u0026#34;: 300, \u0026#39;SQLALCHEMY_DATABASE_URI\u0026#39;: \u0026#39;sqlite:///database.db\u0026#39; } app.config.from_mapping(config) # db 객체 생성 db = SQLAlchemy(app) # 테이블 생성 class VideoModel(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(100), nullable=False) views = db.Column(db.Integer, nullable=False) likes = db.Column(db.Integer, nullable=False) def __repr__(self): return f\u0026#34;Video(name = {self.name}, views = {self.views}, likes = {self.likes})\u0026#34; # 프로젝트 최상위에 db생성 # db.create_all() # 한번만 실행해야함. 첫 실행 후에는 주석처리 # cache initialize cache = Cache(app) # request parser videos_put_args = reqparse.RequestParser() videos_put_args.add_argument(\u0026#34;name\u0026#34;,type=str, help=\u0026#39;Name of the video\u0026#39;,required=True) videos_put_args.add_argument(\u0026#34;views\u0026#34;,type=int, help=\u0026#39;Views of the video\u0026#39;,required=True) videos_put_args.add_argument(\u0026#34;likes\u0026#34;,type=int, help=\u0026#39;Likes of the video\u0026#39;,required=True) # for mashal_with  resources_fields = { \u0026#39;id\u0026#39; : fields.Integer, \u0026#39;name\u0026#39; : fields.String, \u0026#39;views\u0026#39; : fields.Integer, \u0026#39;likes\u0026#39; : fields.Integer } class Video(Resource): # 순서 상관 x # get 404에러시 캐싱이 안되는게 맞는걸까? @marshal_with(resources_fields) @cache.cached(key_prefix=\u0026#39;get%s\u0026#39;) def get(self,video_id): time.sleep(1) result = VideoModel.query.filter_by(id=video_id).first() if not result: abort(404, message=\u0026#34;Could not find video with that id\u0026#34;) return result @marshal_with(resources_fields) def put(self,video_id): args = videos_put_args.parse_args() result = VideoModel.query.filter_by(id=video_id).first() video = VideoModel(id=video_id, name=args[\u0026#39;name\u0026#39;], views=args[\u0026#39;views\u0026#39;], likes=args[\u0026#39;likes\u0026#39;]) db.session.add(video) db.session.commit() cache.delete(f\u0026#39;get/videos/{video_id}\u0026#39;) return video, 201 def delete(self,video_id): result = VideoModel.query.filter_by(id=video_id).delete() db.session.commit() cache.delete(f\u0026#39;get/videos/{video_id}\u0026#39;) return {}, 204 api.add_resource(Video,\u0026#34;/videos/\u0026lt;int:video_id\u0026gt;\u0026#34;) if __name__ == \u0026#34;__main__\u0026#34;: app.run(debug=True)   import sqlalchemy, fields, marshal_with를 추가로 import한다.\n1 2 3 4 5 6  # main.py from flask import Flask, request from flask_restful import Api, Resource, reqparse, abort, fields, marshal_with from flask_caching import Cache from flask_sqlalchemy import SQLAlchemy import time   sqlalchemy는 일종의 ORM이다. 파이썬과 DB를 연결해준다. DB에 저장된 record는 파이썬에서 정의된 class 객체와 대응되게 된다.\ndb 생성 config에 \u0026lsquo;SQLALCHEMY_DATABASE_URI\u0026rsquo;: \u0026lsquo;sqlite:///database.db\u0026rsquo;를 추가하고 db를 이니셜라이즈 한다.\n1 2 3 4 5 6 7 8 9 10  config = { \u0026#34;DEBUG\u0026#34;: True, # some Flask specific configs \u0026#34;CACHE_TYPE\u0026#34;: \u0026#34;SimpleCache\u0026#34;, # Flask-Caching related configs \u0026#34;CACHE_DEFAULT_TIMEOUT\u0026#34;: 300, \u0026#39;SQLALCHEMY_DATABASE_URI\u0026#39;: \u0026#39;sqlite:///database.db\u0026#39; } app.config.from_mapping(config) # db 이니셜라이즈 db = SQLAlchemy(app)   다음과 같이 db에 테이블을 추가할 수 있다. db.create_all()이 실행되면 프로젝트 최상위에 database.db라는 이름으로 파일이 생길 것이다.\ndb.create_all()가 또 다시 실행되면 기존의 데이터들을 갈아엎고 다시 텅빈 database.db 파일을 생성할 거기 때문에, 첫 실행 후에는 주석처리하자.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  # 테이블 생성 class VideoModel(db.Model): id = db.Column(db.Integer, primary_key=True) name = db.Column(db.String(100), nullable=False) # 100자 제한 views = db.Column(db.Integer, nullable=False) likes = db.Column(db.Integer, nullable=False) # print할 때 출력될 내용 def __repr__(self): return f\u0026#34;Video(name = {self.name}, views = {self.views}, likes = {self.likes})\u0026#34; # 프로젝트 최상위에 db생성 # db.create_all() # 한번만 실행해야함. 첫 실행 후에는 주석처리   marshal_with로 VideoModel 인스턴스를 json으로 변환 줄여서 serialization이라고 한다. cache처럼 데코레이터로 활용한다. 먼저 어떤 필드들이 있는지 marshal_with에게 넘겨주기 위해 딕셔너리를 하나 만든다.\n1 2 3 4 5 6 7  # marshal_with  resources_fields = { \u0026#39;id\u0026#39; : fields.Integer, \u0026#39;name\u0026#39; : fields.String, \u0026#39;views\u0026#39; : fields.Integer, \u0026#39;likes\u0026#39; : fields.Integer }   앞서 말한대로 데코레이터로 활용한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  class Video(Resource): # ... # 생략 # ... @marshal_with(resources_fields) def put(self,video_id): # ... # 생략 # ... video = VideoModel(id=video_id, name=args[\u0026#39;name\u0026#39;], views=args[\u0026#39;views\u0026#39;], likes=args[\u0026#39;likes\u0026#39;]) # ... # 생략 # ... return video, 201   cache 데코레이터가 있는 경우, 테스트 결과 순서는 크게 중요하지 않았다. 단지 cache 안의 결과를 저장하는 딕셔너리에 value로써 VideoModel 타입이 들어갈지, json타입이 들거갈 지의 차이다.\nReference  flask-sqlalchemy docs Python REST API Tutorial - Building a Flask REST API  ","description":"","id":30,"section":"docs","tags":["python","flask","rest api"],"title":"Flask로 Restful Api (4): sqlAlchemy로 DB와 연동하기","uri":"https://lyra95.github.io/docs/flask/rest-api-4/"},{"content":"개요 간단한 계산기 프로그램을 예로 들어 설명한다.\nCLI에서 python main.py -op sum 1 2 3이런 식으로 프로그램에 인풋을 주고 싶다고 하자. (결과는 6을 출력하도록)\nsum, mul 함수 작성 (skip) 일단 argparse랑은 상관 없는 sum,mul함수를 작성한다.\n1 2 3 4 5 6 7 8 9 10 11 12  #main.py def sum(args): temp = 0 for num in args: temp += int(num) return temp def mul(args): temp = 1 for num in args: temp *= int(num) return temp   ArgumentParser 다음과 같이 ArgumentParser 오브젝트를 생성한다. 그리고 어떤 종류의 argument를 받을지 .add_argument()로 추가할 수 있다. 물론 .add_argument()를 여러개 해도 된다\n1 2 3 4 5  import argparse parser = argparse.ArgumentParser(description=\u0026#34;usage examples:\\npython main.py -op sum 1 2 3 4\\npython main.py -op mul 1 2 3 4\u0026#34;) parser.add_argument(\u0026#34;-op\u0026#34;, default=\u0026#34;sum\u0026#34;,type=str, choices=[\u0026#34;sum\u0026#34;, \u0026#34;mul\u0026#34;])    description은 python main.py -h를 입력했을 때 보여주게 할 설명을 적으면 된다. add_argument에 대한 API는 docs 참고  파싱은 .parse_known_args()를 통해 할 수 있다. 리턴값은 리터럴 리스트와 Namespace객체의 튜플이다.\n1 2 3  script_arg, args = parser.parse_known_args() # print(type(parser.parse_known_args()),parser.parse_known_args()) # print(args,type(args))   예를 들어 python main.py -op sum 1 2 3라고 cmd에 입력했다면, parser.parse_known_args()의 결과값은 \u0026lt;class 'tuple'\u0026gt; (Namespace(op='sum'), ['1', '2', '3'])이 된다. (궁금하면 주석 빼고 실행해보길)\n다른 argument들을 설정했다면 \u0026lt;class 'tuple'\u0026gt; (Namespace(op='sum', justName=None), ['1', '2', '3'])이런 식으로 될 것이다.\nscript_arg에 Namespace객체가 저장되어있다. 다음과 같이 꺼낼 수 있다.\n1 2 3 4 5 6  if script_arg.op == \u0026#34;sum\u0026#34;: print(sum(args)) elif script_arg.op == \u0026#34;mul\u0026#34;: print(mul(args)) else: raise ValueError(f\u0026#34;undefined input {script_arg.op}\u0026#34;)    만약 add_argument(\u0026quot;-justName\u0026quot;, ...)이 또 있었다면 .justName이라고 하면된다.  동작 예시 어떤 식으로 동작하는지 다음을 참고하자.\n1 2 3 4 5 6 7 8 9 10 11 12 13  PS C:\\dev\\ml\u0026gt; python main.py -h usage: main.py [-h] [-op {sum,mul}] usage examples: python main.py -op sum 1 2 3 4 python main.py -op mul 1 2 3 4 optional arguments: -h, --help show this help message and exit -op {sum,mul} PS C:\\dev\\ml\u0026gt; python main.py -op mul 1 2 3 4 5 120 PS C:\\dev\\ml\u0026gt; python main.py -op abc 12 3 usage: main.py [-h] [-op {sum,mul}] main.py: error: argument -op: invalid choice: \u0026#39;abc\u0026#39; (choose from \u0026#39;sum\u0026#39;, \u0026#39;mul\u0026#39;)   레퍼런스 python docs\n","description":"","id":31,"section":"docs","tags":["python"],"title":"CLI argument parsing : argparse","uri":"https://lyra95.github.io/docs/python/argparse/"},{"content":"저번 포스트에서 이어서\u0026hellip;\n이미지 데이터 한 개는(레이블 제외) 1*28*28 사이즈를 갖는다.\nbatch_size=64이므로 한 번에 64*1*28*28 사이즈의 텐서가 모델에 들어간다.\nNetwork Architecture 설정하기 nn.Module을 상속받는 클래스를 생성하고, __init__, __foward__를 구현해서 모델 아키텍쳐를 설정할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18  from torch import nn class NeuralNetwork(nn.Module): def __init__(self): super(NeuralNetwork, self).__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10), nn.ReLU() ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logits   이제 다음과 같이 모델 인스턴스를 생성하면된다.\n1  model = NeuralNetwork().to(device)    모델 인스턴스을 gpu에 올리기 위해 .to(device)를 사용했다.  print(model)로 모델 아키텍쳐를 확인할 수 있다.\n1 2 3 4 5 6 7 8 9 10 11  NeuralNetwork( (flatten): Flatten(start_dim=1, end_dim=-1) (linear_relu_stack): Sequential( (0): Linear(in_features=784, out_features=512, bias=True) (1): ReLU() (2): Linear(in_features=512, out_features=512, bias=True) (3): ReLU() (4): Linear(in_features=512, out_features=10, bias=True) (5): ReLU() ) )   model에는 한 번에 여러개의 이미지 데이터가 들어갈 수 있다. 예를 들어서 다음과 같이 64개의 이미지(1*28*28) 데이터를 랜덤 생성해서 model에 input으로 넣으면,\n1 2 3  batch_size = 64 imgs = torch.randn(batch_size,1,28,28).to(device) print(model(imgs).shape)   1  torch.Size([64, 10])   이렇게 64개 이미지에 대한 예측 텐서가 나온다.\nmodel.forward(x)를 프린트해보면 model(x)와 같다는 걸 알 수 있다. 즉 forward를 인풋(x)가 모델 네트워크 아키텍쳐를 거쳐서 나오는 아웃풋을 리턴하도록 구현하는 것이다.\nmodel.named_parameters(), model.parameters로 네트워크 아키텍쳐 각 레이어의 파라미터들에 접근할 수 있다.\n1 2  for name, param in model.named_parameters(): print(f\u0026#34;Layer: {name}| Size: {param.size()}| Values : {param[:2]}\\n\u0026#34;)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  Layer: linear_relu_stack.0.weight | Size: torch.Size([512, 784]) | Values : tensor([[ 0.0173, 0.0143, -0.0196, ..., -0.0248, 0.0211, -0.0135], [-0.0005, -0.0077, -0.0185, ..., 0.0282, -0.0144, -0.0277]], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward\u0026gt;) Layer: linear_relu_stack.0.bias | Size: torch.Size([512]) | Values : tensor([-0.0183, -0.0115], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward\u0026gt;) Layer: linear_relu_stack.2.weight | Size: torch.Size([512, 512]) | Values : tensor([[ 0.0267, -0.0254, 0.0438, ..., 0.0313, 0.0486, -0.0073], [-0.0043, 0.0259, 0.0271, ..., 0.0395, -0.0398, -0.0206]], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward\u0026gt;) Layer: linear_relu_stack.2.bias | Size: torch.Size([512]) | Values : tensor([ 0.0035, -0.0162], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward\u0026gt;) Layer: linear_relu_stack.4.weight | Size: torch.Size([10, 512]) | Values : tensor([[ 0.0301, -0.0271, -0.0287, ..., 0.0592, -0.0327, 0.0330], [-0.0630, -0.0218, 0.0230, ..., 0.0007, -0.0350, -0.0216]], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward\u0026gt;) Layer: linear_relu_stack.4.bias | Size: torch.Size([10]) | Values : tensor([-0.0113, 0.0471], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward\u0026gt;)   train loop, test loop 구현 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  def train_loop(dataloader, model, loss_fn, optimizer): size = len(dataloader.dataset) for batch, (X, y) in enumerate(dataloader): X = X.to(device) y = y.to(device) # Compute prediction and loss pred = model(X) loss = loss_fn(pred, y) # Backpropagation optimizer.zero_grad() loss.backward() optimizer.step() if batch % 100 == 0: loss, current = loss.item(), batch * len(X) print(f\u0026#34;loss: {loss:\u0026gt;7f}[{current:\u0026gt;5d}/{size:\u0026gt;5d}]\u0026#34;)    .to(device)를 해야 데이터가 gpu에 올라간다. 매 스탭마다 grad값을 초기화해야하므로 zero_grad()를 쓴다.  optimizer.zero_grad()로 그래디언트값을 초기화하고, loss.backward()로 각 네트워크 아키텍처 레이어의 파라미터에 대한 그래디언트 값을 계산하고, optimizer.step()으로 계산된 그레디언트 값 만큼 각 파라미터들을 adjust한다.\n 딥러닝이란게 결국 이론적으로, 네트워크 파라미터들의 공간 상의 임의의 한 점에서, loss fuction의 최솟값이 되는 점을 향해(gradient 방향) 조금씩 이동하며 최솟값 지점을 찾는 것이다.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  def test_loop(dataloader, model, loss_fn): size = len(dataloader.dataset) test_loss, correct = 0, 0 with torch.no_grad(): for X, y in dataloader: X = X.to(device) y = y.to(device) pred = model(X) test_loss += loss_fn(pred, y).item() correct += (pred.argmax(1) == y).type(torch.float).sum().item() test_loss /= size correct /= size print(f\u0026#34;Test Error: \\nAccuracy: {(100*correct):\u0026gt;0.1f}%, Avg loss: {test_loss:\u0026gt;8f}\\n\u0026#34;)   하이퍼 파라미터 설정 1 2 3  loss_fn = nn.CrossEntropyLoss().to(device) learning_rate = 1e-3 optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate)   CrossEntropyLoss, SGD(stochastic gradient descent) 참고.\nCrossEntropyLoss는 지금과 같은 classification에 적절한 loss function이다. (regression 같은 경우 Mean Square Error 같은게 적절하다.)\nSGD는 네트워크 파라미터들을 (gradient)/*learning_rate만큼 adjust해주는 옵티마이저 함수다.\n트레이닝 하기 1 2 3 4 5 6 7 8 9 10  import time start = time.process_time() epochs = 5 for t in range(epochs): print(f\u0026#34;Epoch {t+1}\\n-------------------------------\u0026#34;) train_loop(train_dataloader, model, loss_fn, optimizer) test_loop(test_dataloader, model, loss_fn) print(\u0026#34;Done!\u0026#34;) elapsed = time.process_time() - start print(elapsed)   매 루프마다 train_loop와 test_loop를 한 번 씩 실행한다. 데이터 로딩할떄 shuffle=True를 줬으므로, 그때그때 데이터 순서는 달라진다.\ntime 라이브러리를 활용해서 총 걸리는 시간을 재보았다. (gpu 40초 / cpu 200초 정도)\n네트워크 파라미터들을 보면 조금 달라진 것을 알 수 있다.\n1 2  for name, param in model.named_parameters(): print(f\u0026#34;Layer: {name}| Size: {param.size()}| Values : {param[:2]}\\n\u0026#34;)   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  Layer: linear_relu_stack.0.weight | Size: torch.Size([512, 784]) | Values : tensor([[-0.0281, -0.0329, -0.0056, ..., 0.0345, -0.0171, 0.0036], [ 0.0189, -0.0298, -0.0091, ..., -0.0213, 0.0022, -0.0199]], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward\u0026gt;) Layer: linear_relu_stack.0.bias | Size: torch.Size([512]) | Values : tensor([ 0.0055, -0.0174], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward\u0026gt;) Layer: linear_relu_stack.2.weight | Size: torch.Size([512, 512]) | Values : tensor([[-0.0050, 0.0341, 0.0291, ..., -0.0029, -0.0033, 0.0412], [ 0.0176, 0.0081, -0.0205, ..., 0.0429, 0.0473, -0.0005]], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward\u0026gt;) Layer: linear_relu_stack.2.bias | Size: torch.Size([512]) | Values : tensor([-0.0007, 0.0297], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward\u0026gt;) Layer: linear_relu_stack.4.weight | Size: torch.Size([10, 512]) | Values : tensor([[ 0.0511, -0.0308, 0.0171, ..., -0.0294, 0.0052, -0.0327], [-0.0407, -0.0375, -0.0079, ..., -0.0263, -0.0076, 0.0434]], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward\u0026gt;) Layer: linear_relu_stack.4.bias | Size: torch.Size([10]) | Values : tensor([0.0302, 0.0821], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;SliceBackward\u0026gt;)   실험삼아 다음 그림을 model에 넣어서 결과를 보자. (매번 셔플되므로 그림은 실행할 때마다 다르다)\n1 2 3 4 5 6 7  import matplotlib.pyplot as plt # Display image and label. train_features, train_labels = next(iter(train_dataloader)) img = train_features[0].squeeze() label = train_labels[0] plt.imshow(img, cmap=\u0026#34;gray\u0026#34;) plt.show()   1  model(img.unsqueeze(0).unsqueeze(0).to(device))   1 2  tensor([[0.0000, 0.0000, 0.0760, 0.0000, 0.0061, 3.4088, 0.0000, 3.1719, 3.3842, 5.4894]], device=\u0026#39;cuda:0\u0026#39;, grad_fn=\u0026lt;ReluBackward0\u0026gt;)    unsqueeze에 대해서는 일단 넘어가자\n 제일 마지막 값(label=9) 5.4894가 제일 크다. label=9는 Ankel boots이므로 모델이 성공적으로 예측했다고 볼 수 있다.\n모델 저장/로드 다음과 같이 model을 프로젝트 최상위에 model_weights.pt라는 이름으로 저장할 수 있다.\n1 2 3 4  import torch import torch.onnx as onnx import torchvision.models as models torch.save(model.state_dict(), \u0026#39;model_weights.pt\u0026#39;)   로드를 할 때는 먼저 인스턴스를 하나 이니셜라이즈한 후 로드해온다.\n1 2 3  model2 = NeuralNetwork().to(device) model2.load_state_dict(torch.load(\u0026#39;model_weights.pt\u0026#39;)) model2.eval()    be sure to call model.eval() method before inferencing to set the dropout and batch normalization layers to evaluation mode. Failing to do this will yield inconsistent inference results.\n 다른 방법도 있다. 인스턴스를 이니셜라이제이션할 필요가 없다.\n1 2  torch.save(model, \u0026#39;model.pth\u0026#39;) model2 = torch.load(\u0026#39;model.pth\u0026#39;)   또 다른 방법으로, 파이토치 이외의 플랫폼에서도 로드를 하고 싶으면 .onnx 확장자로 다음과 같이 저장한다.\n1 2  input_image = torch.zeros((1,1,28,28)).to(device) onnx.export(model, input_image, \u0026#39;model.onnx\u0026#39;)    onnx 튜토리얼 참고\n 마치며 autograd의 메카니즘에 대해 자세히 알면 알수록 좋다. (chain rule, jacobian matrix)\nboiler plate들이 많은데 다음 번에는 torch lightning을 쓰는 튜토리얼을 작성해보려고 한다.\n","description":"","id":32,"section":"docs","tags":["pytorch","mnist"],"title":"Network, Save \u0026 Load : Pytorch tutorial (2)","uri":"https://lyra95.github.io/docs/ml/mnist2/"},{"content":"Hugo에 수식을 쓰고 싶으면 mathjax 플러그인을 쓰면된다.\nmathjax_support.html 생성 먼저 mathjax를 로딩해주는 html 파일을 작성한다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  \u0026lt;!--mathjax_support.html--\u0026gt; \u0026lt;script\u0026gt; MathJax = { tex: { inlineMath: [[\u0026#39;$\u0026#39;, \u0026#39;$\u0026#39;], [\u0026#39;\\\\(\u0026#39;, \u0026#39;\\\\)\u0026#39;]], displayMath: [[\u0026#39;$$\u0026#39;,\u0026#39;$$\u0026#39;], [\u0026#39;\\\\[\u0026#39;, \u0026#39;\\\\]\u0026#39;]], processEscapes: true, processEnvironments: true }, options: { skipHtmlTags: [\u0026#39;script\u0026#39;, \u0026#39;noscript\u0026#39;, \u0026#39;style\u0026#39;, \u0026#39;textarea\u0026#39;, \u0026#39;pre\u0026#39;] } }; window.addEventListener(\u0026#39;load\u0026#39;, (event) =\u0026gt; { document.querySelectorAll(\u0026#34;mjx-container\u0026#34;).forEach(function(x){ x.parentElement.classList += \u0026#39;has-jax\u0026#39;}) }); \u0026lt;/script\u0026gt; \u0026lt;script src=\u0026#34;https://polyfill.io/v3/polyfill.min.js?features=es6\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; id=\u0026#34;MathJax-script\u0026#34; async src=\u0026#34;https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt;   특정 테마를 사용중이라면 {프로젝트최상위}/themes/{theme이름}/layouts/partials 폴더에 저런 html파일들이 들어가 있는데, 위에서 만든 mathjax_support.html을 이 밑의 아무곳에나 둔다.(경로를 기억할 것)\n필자는 math라는 디렉토리를 layouts/partials밑에 생성해서, {생략}/layouts/partials/math/mathjax_support.html 라는 경로가 되었다. (파일이름을 포함한 경로만 기억하면 본인 마음대로 해도 된다. mathjax_load.html로 하든 말든)\nfooter.html에 line추가하기 여기서 살짝 편법을 쓴다.\n보통 모든 게시글에는 꼬릿말이 있기에, footer.html을 로딩하게 된다. 그래서 footer.html 로딩되는김에 겸사겸사 mathjax_support.html도 로딩하라고 코드를 한 줄 추가해준다.\nfooter.html은 layouts/partials 밑의 어딘가에 있을 것이다. 못 찾겠으면 반드시 로딩될 것 같은 다른 html에 해도 된다.\n만일 필자처럼 mathjax_support.html경로를 설정했다면, 다음과 같은 코드를 추가하면 된다.\n1 2 3 4 5 6  \u0026lt;!--footer.html--\u0026gt; \u0026lt;!--어쩌고저쩌고 코드들--\u0026gt; \u0026lt;!--마지막 줄에 아래 코드를 추가--\u0026gt; {{ if $.Param \u0026#34;mathjax\u0026#34; }}{{ partial \u0026#34;math/mathjax_support.html\u0026#34; . }}{{ end }}   사용법 글을 쓸 마크다운 파일에서 프론트매터에 mathjax : true라고 타입하면 된다. 문법은 latex이랑 거의 같고, inline은 $, display는 $$로 하면된다.\n","description":"","id":33,"section":"docs","tags":["math","blog","setting"],"title":"Hugo Mathjax Setting","uri":"https://lyra95.github.io/docs/blogging/mathjax/"},{"content":" 본 항목은 생활코딩을 참고하였습니다.\n 이전 포스트에서 topic 테이블을 생성하고 레코드들을 추가했습니다.1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt;SELECT*FROMtopic;+----+------------+--------------------+---------------------+--------+--------------------------+ |id|title|description|created|author|profile|+----+------------+--------------------+---------------------+--------+--------------------------+ |1|MySQL|MySQLis...|2018-01-1000:00:00|egoing|developer||2|ORACLE|Oracleis...|2021-05-0618:17:04|egoing|developer||3|SQLServer|SQLServeris...|2021-05-0618:27:09|duru|databaseadministrator||4|PostgreSQL|PostgreSQLis...|2021-05-0618:27:24|taeho|datascientist,developer||5|MongoDB|MongoDBis...|2021-05-0618:27:43|egoing|developer|+----+------------+--------------------+---------------------+--------+--------------------------+ 5rowsinset(0.00sec)  아마 대부분의 경우, 데이터베이스/테이블을 생성하거나 레코드를 추가하거나 하는 일은 많이 없습니다. 하지만 SELECT를 적절히 활용해 원하는 데이터를 찾아야할 일은 많이 있을 겁니다.\nMySQL doc을 참고하면, SELECT의 정확한 문법은 다음과 같습니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32  SELECT[ALL|DISTINCT|DISTINCTROW][HIGH_PRIORITY][STRAIGHT_JOIN][SQL_SMALL_RESULT][SQL_BIG_RESULT][SQL_BUFFER_RESULT][SQL_NO_CACHE][SQL_CALC_FOUND_ROWS]select_expr[,select_expr]...[into_option][FROMtable_references[PARTITIONpartition_list]][WHEREwhere_condition][GROUPBY{col_name|expr|position},...[WITHROLLUP]][HAVINGwhere_condition][WINDOWwindow_nameAS(window_spec)[,window_nameAS(window_spec)]...][ORDERBY{col_name|expr|position}[ASC|DESC],...[WITHROLLUP]][LIMIT{[offset,]row_count|row_countOFFSEToffset}][into_option][FOR{UPDATE|SHARE}[OFtbl_name[,tbl_name]...][NOWAIT|SKIPLOCKED]|LOCKINSHAREMODE][into_option]into_option:{INTOOUTFILE\u0026#39;file_name\u0026#39;[CHARACTERSETcharset_name]export_options|INTODUMPFILE\u0026#39;file_name\u0026#39;|INTOvar_name[,var_name]...}   [ ] 은 생략가능한 키워드들 입니다. |은 여러개의 키워드 중에 하나를 고를 수 있다는 것입니다. [ALL | DISTINCT | DISTINCTROW ]에서 다 생략하거나, 셋 중 하나를 고를 수 있습니다.   이전의 CREATE, INSERT 커맨드도 한 번 doc을 찾아보세요.\n 본 항목에서는 몇가지 경우만 시도해 봅시다.\n특정 attribute들만 보기 예를 들어 title, author, profile만 보고 싶다면 다음과 같이 SELECT를 활용합니다.\n1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt;SELECTtitle,author,profileFROMtopic;+------------+--------+--------------------------+ |title|author|profile|+------------+--------+--------------------------+ |MySQL|egoing|developer||ORACLE|egoing|developer||SQLServer|duru|databaseadministrator||PostgreSQL|taeho|datascientist,developer||MongoDB|egoing|developer|+------------+--------+--------------------------+ 5rowsinset(0.00sec)  *를 활용하면 모든 attribute를 볼 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt;SELECT*FROMtopic;+----+------------+--------------------+---------------------+--------+--------------------------+ |id|title|description|created|author|profile|+----+------------+--------------------+---------------------+--------+--------------------------+ |1|MySQL|MySQLis...|2018-01-1000:00:00|egoing|developer||2|ORACLE|Oracleis...|2021-05-0618:17:04|egoing|developer||3|SQLServer|SQLServeris...|2021-05-0618:27:09|duru|databaseadministrator||4|PostgreSQL|PostgreSQLis...|2021-05-0618:27:24|taeho|datascientist,developer||5|MongoDB|MongoDBis...|2021-05-0618:27:43|egoing|developer|+----+------------+--------------------+---------------------+--------+--------------------------+ 5rowsinset(0.00sec)  ORDER : 순서대로 보기 예를 들어 author값의 내림차순으로 보고 싶다면 다음과 같이 커맨드를 입력합니다.\n1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt;SELECTid,title,author,profileFROMtopicORDERBYauthor;+----+------------+--------+--------------------------+ |id|title|author|profile|+----+------------+--------+--------------------------+ |3|SQLServer|duru|databaseadministrator||1|MySQL|egoing|developer||2|ORACLE|egoing|developer||5|MongoDB|egoing|developer||4|PostgreSQL|taeho|datascientist,developer|+----+------------+--------+--------------------------+ 5rowsinset(0.00sec)  오름차순으로 보고 싶다면 author 뒤에 DESC를 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt;SELECTid,title,author,profileFROMtopicORDERBYauthorDESC;+----+------------+--------+--------------------------+ |id|title|author|profile|+----+------------+--------+--------------------------+ |4|PostgreSQL|taeho|datascientist,developer||1|MySQL|egoing|developer||2|ORACLE|egoing|developer||5|MongoDB|egoing|developer||3|SQLServer|duru|databaseadministrator|+----+------------+--------+--------------------------+ 5rowsinset(0.00sec)  약간의 응용을 해서, author를 기준으로 내림차순하면서, 같은 author의 경우 id를 기준으로 오름차순하려면 다음과 같이 하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt;SELECTid,title,author,profileFROMtopicORDERBYauthor,idDESC;+----+------------+--------+--------------------------+ |id|title|author|profile|+----+------------+--------+--------------------------+ |3|SQLServer|duru|databaseadministrator||5|MongoDB|egoing|developer||2|ORACLE|egoing|developer||1|MySQL|egoing|developer||4|PostgreSQL|taeho|datascientist,developer|+----+------------+--------+--------------------------+ 5rowsinset(0.00sec)  WHERE : 조건에 해당하는 것만 보기 author가 egoing인 것만 보려면 WHERE author='egoing'을 추가하면 됩니다.\n1 2 3 4 5 6 7 8 9  mysql\u0026gt;SELECTid,title,author,profileFROMtopicWHEREauthor=\u0026#39;egoing\u0026#39;;+----+---------+--------+-----------+ |id|title|author|profile|+----+---------+--------+-----------+ |1|MySQL|egoing|developer||2|ORACLE|egoing|developer||5|MongoDB|egoing|developer|+----+---------+--------+-----------+ 3rowsinset(0.00sec)  id 내림차순으로 보려면 ORDER를 WHERE 다음에 추가해야합니다.\n1 2 3 4 5 6 7 8 9  mysql\u0026gt;SELECTid,title,author,profileFROMtopicWHEREauthor=\u0026#39;egoing\u0026#39;ORDERBYidDESC;+----+---------+--------+-----------+ |id|title|author|profile|+----+---------+--------+-----------+ |5|MongoDB|egoing|developer||2|ORACLE|egoing|developer||1|MySQL|egoing|developer|+----+---------+--------+-----------+ 3rowsinset(0.00sec)  WHERE {조건문}으로 다양한 조건을 걸 수 있습니다.\n1 2 3 4 5 6 7 8 9 10  mysql\u0026gt;SELECT*FROMtopicWHEREcreated\u0026gt;\u0026#39;2020-01-01\u0026#39;;+----+------------+--------------------+---------------------+--------+--------------------------+ |id|title|description|created|author|profile|+----+------------+--------------------+---------------------+--------+--------------------------+ |2|ORACLE|Oracleis...|2021-05-0618:17:04|egoing|developer||3|SQLServer|SQLServeris...|2021-05-0618:27:09|duru|databaseadministrator||4|PostgreSQL|PostgreSQLis...|2021-05-0618:27:24|taeho|datascientist,developer||5|MongoDB|MongoDBis...|2021-05-0618:27:43|egoing|developer|+----+------------+--------------------+---------------------+--------+--------------------------+ 4rowsinset(0.00sec)  LIMIT : 몇개만 보여주기 예제와는 달리 실제에서는 데이터베이스 테이블에 몇 만, 몇 십만개의 레코드가 있을 수도 있습니다. 조건에 맞는 레코드만 출력하더라도 개수가 많고 오래걸릴 수 있습니다.\n몇 개만 찾고 끝내고 싶다면 LIMIT {숫자} 키워드를 이용하세요.\n1 2 3 4 5 6 7 8  mysql\u0026gt;SELECT*FROMtopicWHEREcreated\u0026gt;\u0026#39;2020-01-01\u0026#39;LIMIT2;+----+------------+------------------+---------------------+--------+------------------------+ |id|title|description|created|author|profile|+----+------------+------------------+---------------------+--------+------------------------+ |2|ORACLE|Oracleis...|2021-05-0618:17:04|egoing|developer||3|SQLServer|SQLServeris...|2021-05-0618:27:09|duru|databaseadministrator|+----+------------+------------------+---------------------+--------+------------------------+ 2rowsinset(0.00sec)  FROM 생략가능 doc을 보면 FROM이 생략가능하다고 나옵니다.\n1 2 3 4 5 6 7  mysql\u0026gt;SELECT1+1,\u0026#39;Hi, ...\u0026#39;;+-----+---------+ |1+1|Hi,...|+-----+---------+ |2|Hi,...|+-----+---------+ 1rowinset(0.00sec)   별 의미 없는 부분입니다. 이렇게 되구나 하고 넘어가세요.\n 다음에는 DELETE에 대해 알아보겠습니다.\n","description":"","id":34,"section":"docs","tags":["mysql","db","crud"],"title":"(4) : CRUD commands, SELECT","uri":"https://lyra95.github.io/docs/mysqltutorial/mysql-4/"},{"content":"테스트 여러개 생성 그냥 Test 함수를 여러개 작성하면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28  // prime_test.go func TestPrimeZero(t *testing.T) { result := prime(0) if result != 0 { t.Errorf(\u0026#34;prime(0) should be 0 but prime(0) returns %d\u0026#34;, result) } } func TestPrimeNegative(t *testing.T) { result := prime(-100) if result != 0 { t.Errorf(\u0026#34;prime(-100) should be 0 but prime(-100) returns %d\u0026#34;, result) } } func TestPrime100(t *testing.T) { result := prime(100) if result != 25 { t.Errorf(\u0026#34;prime(100) should be 25 but prime(100) returns %d\u0026#34;, result) } } func TestPrime1000(t *testing.T) { result := prime(1000) if result != 168 { t.Errorf(\u0026#34;prime(1000) should be 168 but prime(100) returns %d\u0026#34;, result) } }   test 일부만 실행 go test -run {테스트이름}으로 일부 테스트만 실행할 수 있습니다.\n1 2 3 4  PS C:\\dev\\goproject\\prime\u0026gt; go test -run Prime1000 PASS ok prime 4.289s PS C:\\dev\\goproject\\prime\u0026gt;    이름에서 Test부분은 빠집니다!\n go test -run Prime을 입력하면 이름이 Prime으로 시작하는 모든 테스트를 실행합니다.\nt.Error(), t.Fail() t.Error()는 테스트가 실패하면 모든 테스트를 중단합니다. 반면에 t.Fail()은 테스트가 실패해도 다른 테스트들을 계속 진행합니다.\n T.Errorf()에서 f는 format string의 f입니다.\n t.Fail()을 이용할 시에는 실패 메시지 출력을 위해 t.Log() 나 t.Logf()를 활용하세요. t.Fail() 플래그가 셋되면(=테스트가 실패하면) 메시지가 출력됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37  // prime_test.go func TestFail(t *testing.T) { t.Fail() t.Log(\u0026#34;this test must fail\u0026#34;) } func TestPrime100(t *testing.T) { result := prime(100) if result != 25 { t.Fail() t.Logf(\u0026#34;prime(100) should be 25 but prime(100) returns %d\u0026#34;, result) } } func TestPrime1000(t *testing.T) { result := prime(1000) if result != 168 { t.Fail() t.Logf(\u0026#34;prime(1000) should be 168 but prime(1000) returns %d\u0026#34;, result) } } func TestPrimeZero(t *testing.T) { result := prime(0) if result != 0 { t.Fail() t.Logf(\u0026#34;prime(0) should be 0 but prime(100) returns %d\u0026#34;, result) } } func TestPrimeNegative(t *testing.T) { result := prime(-100) if result != 0 { t.Fail() t.Logf(\u0026#34;prime(-100) should be 0 but prime(100) returns %d\u0026#34;, result) } }   테스트를 해봅시다.\n1 2 3 4 5 6 7  PS C:\\dev\\goproject\\prime\u0026gt; go test --- FAIL: TestFail (0.00s) prime_test.go:7: this test must fail FAIL exit status 1 FAIL prime 3.925s PS C:\\dev\\goproject\\prime\u0026gt;   쉘 출력문만 봐서는 나머지 테스트들이 진행되었는지 알 수 없네요.\ngo test -v를 실행시켜 봅시다 (verbose의 v입니다.)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  PS C:\\dev\\goproject\\prime\u0026gt; go test -v === RUN TestFail prime_test.go:7: this test must fail --- FAIL: TestFail (0.00s) === RUN TestPrime100 --- PASS: TestPrime100 (0.00s) === RUN TestPrime1000 --- PASS: TestPrime1000 (0.00s) === RUN TestPrimeZero --- PASS: TestPrimeZero (0.00s) === RUN TestPrimeNegative --- PASS: TestPrimeNegative (0.00s) FAIL exit status 1 FAIL prime 3.317s   각 테스트 결과를 다 보여주네요.\nstretchr/testify 패키지 이 패키지에서는 테스트에 유용한 함수들을 제공합니다.\n터미널에 go get github/stretchr/testify를 입력하여 패키지를 다운받습니다.\nassert.Equal(참값, 결과값, 실패시 메시지) 함수로 더 간결하게 코드를 작성할 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11  package main import ( \u0026#34;testing\u0026#34; \u0026#34;github.com/stretchr/testify/assert\u0026#34; ) func TestPrime100(t *testing.T) { assert := assert.New(t) assert.Equal(25, prime(100), \u0026#34;prime(100) should be 25\u0026#34; ) }   실패시 어떻게 메시지가 출력되나 보기 위해 TestPrime100을 조금 바꿔봅니다.\n1 2 3 4  func TestPrime100(t *testing.T) { assert := assert.New(t) assert.Equal(0, prime(100), \u0026#34;prime(100) should be 0\u0026#34; ) }   테스트 실행 시 다음과 같이 상세하게 알려줍니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  PS C:\\dev\\goproject\\prime\u0026gt; go test -v === RUN TestPrime100 prime_test.go:11: Error Trace: prime_test.go:11 Error: Not equal: expected: 0 actual : 25 Test: TestPrime100 Messages: prime(100) should be 0 --- FAIL: TestPrime100 (0.00s) === RUN TestPrime1000 --- PASS: TestPrime1000 (0.00s) === RUN TestPrimeZero --- PASS: TestPrimeZero (0.00s) === RUN TestPrimeNegative --- PASS: TestPrimeNegative (0.00s) FAIL exit status 1 FAIL prime 3.948s   Equal() 이외에도 NotEqualf(), NotNilf() 등 많은 함수가 해당 패키지에서 제공됩니다.\n다음 주제들 벤치마크를 하는 법, 고루틴을 이용한 prime함수 개선, 분산 처리 하는 법(뮤텍스, 채널, 작업영역 분산 등등)을 다루겠습니다.\n","description":"","id":35,"section":"docs","tags":["golang","test","benchmark"],"title":"(1)-2 : golang test","uri":"https://lyra95.github.io/docs/go/go-test-2/"},{"content":"Lightning in 2 steps 참고.\nMigration할 코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82  import torch device = \u0026#39;cuda\u0026#39; if torch.cuda.is_available() else \u0026#39;cpu\u0026#39; from torch.utils.data import Dataset from torchvision import datasets from torchvision.transforms import ToTensor training_data = datasets.FashionMNIST(root=\u0026#34;data\u0026#34;, train=True,download=True,transform=ToTensor()) test_data = datasets.FashionMNIST(root=\u0026#34;data\u0026#34;, train=False,download=True,transform=ToTensor()) from torch.utils.data import DataLoader train_dataloader = DataLoader(training_data, batch_size=64, shuffle=True) test_dataloader = DataLoader(test_data, batch_size=64, shuffle=True) from torch import nn class NeuralNetwork(nn.Module): def __init__(self): super(NeuralNetwork, self).__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10), nn.ReLU() ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logits model = NeuralNetwork().to(device) def train_loop(dataloader, model, loss_fn, optimizer): size = len(dataloader.dataset) for batch, (X, y) in enumerate(dataloader): X = X.to(device) y = y.to(device) # Compute prediction and loss pred = model(X) loss = loss_fn(pred, y) # Backpropagation optimizer.zero_grad() loss.backward() optimizer.step() if batch % 100 == 0: loss, current = loss.item(), batch * len(X) print(f\u0026#34;loss: {loss:\u0026gt;7f}[{current:\u0026gt;5d}/{size:\u0026gt;5d}]\u0026#34;) def test_loop(dataloader, model, loss_fn): size = len(dataloader.dataset) test_loss, correct = 0, 0 with torch.no_grad(): for X, y in dataloader: X = X.to(device) y = y.to(device) pred = model(X) test_loss += loss_fn(pred, y).item() correct += (pred.argmax(1) == y).type(torch.float).sum().item() test_loss /= size correct /= size print(f\u0026#34;Test Error: \\nAccuracy: {(100*correct):\u0026gt;0.1f}%, Avg loss: {test_loss:\u0026gt;8f}\\n\u0026#34;) loss_fn = nn.CrossEntropyLoss().to(device) learning_rate = 1e-3 optimizer = torch.optim.SGD(model.parameters(), lr=learning_rate) epochs = 5 for t in range(epochs): print(f\u0026#34;Epoch {t+1}\\n-------------------------------\u0026#34;) train_loop(train_dataloader, model, loss_fn, optimizer) test_loop(test_dataloader, model, loss_fn) print(\u0026#34;Done!\u0026#34;)   Defining Network Module NeuralNetwork, training_loop, test_loop, hyper parameter 설정은 모두 이 class안으로 모아준다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34  import os import torch from torch import nn import torch.nn.functional as F import pytorch_lightning as pl class NeuralNetwork(pl.LightningModule): def __init__(self): super().__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10), nn.ReLU() ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logits def training_step(self, batch, batch_idx): x, y = batch z = self.forward(x) loss = F.cross_entropy(z,y) self.log(\u0026#39;train_loss\u0026#39;, loss) return loss def configure_optimizers(self): optimizer = torch.optim.SGD(self.parameters(), lr = 1e-3) return optimizer    training_step에서 forward 쓰지 말라고 권고하지만 일단 왜인지 모르겠으니 쓰고본다.\n Defining Data Module MNIST data 다운로드, 로딩부분은 Data module class로 모은다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  from torchvision import datasets from torchvision.transforms import ToTensor from torch.utils.data import DataLoader, random_split from typing import Optional class MyDataModule(pl.LightningDataModule): def __init__(self, data_dir: str = \u0026#34;./data\u0026#34;, batch_size: int = 64, num_workers = 1): super().__init__() self.data_dir = data_dir self.batch_size = batch_size self.num_workers = num_workers def setup(self, stage: Optional[str] = None): self.mnist_test = datasets.FashionMNIST(root=self.data_dir, train=False, download=True, transform=ToTensor()) mnist_full = datasets.FashionMNIST(root=self.data_dir, train=True,download=True,transform=ToTensor()) self.mnist_train, self.mnist_val = random_split(mnist_full, [55000, 5000]) def train_dataloader(self): return DataLoader(self.mnist_train, batch_size=self.batch_size, shuffle=True, num_workers=self.num_workers) def val_dataloader(self): return DataLoader(self.mnist_val, batch_size=self.batch_size, shuffle=True, num_workers=self.num_workers) def test_dataloader(self): return DataLoader(self.mnist_test, batch_size=self.batch_size, shuffle=True, num_workers=self.num_workers)   Optional을 이용해서 string arg별로 다른 behavior를 설정할 수 있다. 예시:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  def setup(self, stage: Optional[str] = None): # Assign train/val datasets for use in dataloaders if stage == \u0026#39;fit\u0026#39; or stage is None: mnist_full = MNIST(self.data_dir, train=True, transform=self.transform) self.mnist_train, self.mnist_val = random_split(mnist_full, [55000, 5000]) # Optionally... # self.dims = tuple(self.mnist_train[0][0].shape) # Assign test dataset for use in dataloader(s) if stage == \u0026#39;test\u0026#39; or stage is None: self.mnist_test = MNIST(self.data_dir, train=False, transform=self.transform) # Optionally... # self.dims = tuple(self.mnist_test[0][0].shape)   Module 인스턴스 생성 및 트레이닝 다음과 같이 모듈 인스턴스를 생성한다.\n1 2 3  model = NeuralNetwork() dm = MyDataModule(data_dir=\u0026#34;./lightningData\u0026#34;, num_workers = 12) dm.setup()    num_workers는 쓰레드 수다.\n 트레이닝 설정은 다음과 같이 하면 된다.\n1 2  from pytorch_lightning import Trainer trainer = Trainer(gpus=1, max_epochs=10)   1 2  GPU available: True, used: True TPU available: False, using: 0 TPU cores   Trainier의 파라미터로 여러 설정들을 정할 수 있다. gpus는 사용할 gpu 수, max_epochs는 트레이닝 반복 횟수다.\n콘솔 출력으로 사용가능한/선택된 디바이스를 알 수 있다.\n트레이닝은 다음과 같이 하면 된다.\n1  trainer.fit(model,dm.train_dataloader(), dm.test_dataloader())   .fit 외에도 .test도 있다. 각각 Optional에서 behavior를 정해줄 수 있다.\nMigration 후 전체코드 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72  import os import torch from torch import nn import torch.nn.functional as F import pytorch_lightning as pl class NeuralNetwork(pl.LightningModule): def __init__(self): super().__init__() self.flatten = nn.Flatten() self.linear_relu_stack = nn.Sequential( nn.Linear(28*28, 512), nn.ReLU(), nn.Linear(512, 512), nn.ReLU(), nn.Linear(512, 10), nn.ReLU() ) def forward(self, x): x = self.flatten(x) logits = self.linear_relu_stack(x) return logits def training_step(self, batch, batch_idx): x, y = batch z = self.forward(x) loss = F.cross_entropy(z,y) self.log(\u0026#39;train_loss\u0026#39;, loss) return loss def configure_optimizers(self): optimizer = torch.optim.SGD(self.parameters(), lr = 1e-3) return optimizer from torchvision import datasets from torchvision.transforms import ToTensor from torch.utils.data import DataLoader, random_split from typing import Optional class MyDataModule(pl.LightningDataModule): def __init__(self, data_dir: str = \u0026#34;./data\u0026#34;, batch_size: int = 64, num_workers = 1): super().__init__() self.data_dir = data_dir self.batch_size = batch_size self.num_workers = num_workers def setup(self, stage: Optional[str] = None): self.mnist_test = datasets.FashionMNIST(root=self.data_dir, train=False, download=True, transform=ToTensor()) mnist_full = datasets.FashionMNIST(root=self.data_dir, train=True,download=True,transform=ToTensor()) self.mnist_train, self.mnist_val = random_split(mnist_full, [55000, 5000]) def train_dataloader(self): return DataLoader(self.mnist_train, batch_size=self.batch_size, shuffle=True, num_workers=self.num_workers) def val_dataloader(self): return DataLoader(self.mnist_val, batch_size=self.batch_size, shuffle=True, num_workers=self.num_workers) def test_dataloader(self): return DataLoader(self.mnist_test, batch_size=self.batch_size, shuffle=True, num_workers=self.num_workers) model = NeuralNetwork() dm = MyDataModule(data_dir=\u0026#34;./lightningData\u0026#34;, num_workers = 12) dm.setup() from pytorch_lightning import Trainer trainer = Trainer(gpus=1, max_epochs=10) trainer.fit(model,dm.train_dataloader(), dm.test_dataloader())   ","description":"","id":36,"section":"docs","tags":["pytorch","mnist"],"title":"Migration to Pytorch Lightning : Pytorch tutorial (3)","uri":"https://lyra95.github.io/docs/ml/mnist3/"},{"content":"DELETE는 어렵지 않습니다.\nid값이 3인 레코드를 지워봅시다.\n1 2  mysql\u0026gt;DELETEFROMtopicWHEREid=3;QueryOK,1rowaffected(0.00sec)   CAUTION : WHERE을 깜빡하면 모든 레코드가 지워집니다!\n SELECT로 테이블을 확인해봅시다.\n1 2 3 4 5 6 7 8 9 10  mysql\u0026gt;SELECT*FROMtopic;+----+------------+--------------------+---------------------+--------+--------------------------+ |id|title|description|created|author|profile|+----+------------+--------------------+---------------------+--------+--------------------------+ |1|MySQL|MySQLis...|2018-01-1000:00:00|egoing|developer||2|ORACLE|Oracleis...|2021-05-0618:17:04|egoing|developer||4|PostgreSQL|PostgreSQLis...|2021-05-0618:27:24|taeho|datascientist,developer||5|MongoDB|MongoDBis...|2021-05-0618:27:43|egoing|developer|+----+------------+--------------------+---------------------+--------+--------------------------+ 4rowsinset(0.00sec)  복습할 겸 이후에 레코드를 추가하면 어떻게 되나 봅시다.\n AUTO_INCREMENT가 어떻게 적용되나 봅시다.\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14  mysql\u0026gt;INSERTINTOtopic(title,created)VALUES(\u0026#39;JO\u0026#39;,NOW());QueryOK,1rowaffected(0.00sec)mysql\u0026gt;SELECT*FROMtopic;+----+------------+--------------------+---------------------+--------+--------------------------+ |id|title|description|created|author|profile|+----+------------+--------------------+---------------------+--------+--------------------------+ |1|MySQL|MySQLis...|2018-01-1000:00:00|egoing|developer||2|ORACLE|Oracleis...|2021-05-0618:17:04|egoing|developer||4|PostgreSQL|PostgreSQLis...|2021-05-0618:27:24|taeho|datascientist,developer||5|MongoDB|MongoDBis...|2021-05-0618:27:43|egoing|developer||6|JO|NULL|2021-05-0620:14:49|NULL|NULL|+----+------------+--------------------+---------------------+--------+--------------------------+ 5rowsinset(0.00sec)  3을 건너뛰고 6이 되었습니다. id attribute의 역할은 레코드와 일대일 대응이 되는 식별자입니다. 중복이 없는 한 비어있는 건 괜찮습니다.\n마치며 여기까지해서 MySQL의 문법을 대체적으로 알아보았습니다. 사실 터미널이 아닌 GUI로 MySQL을 사용할 수 있습니다. (무료 라이센스 프로그램으로 MySQL Workbench가 있습니다.)\n하지만 기본적인 기능에 집중하기 위해 터미널에서 커맨드를 통해 mysql을 다루는 방법을 알아보았습니다.\n","description":"","id":37,"section":"docs","tags":["mysql","db","crud"],"title":"(5) : CRUD commands, DELETE","uri":"https://lyra95.github.io/docs/mysqltutorial/mysql-5/"},{"content":"Golang은 벤치마크 기능을 지원합니다. 테스트와 마찬가지로\n   _test.go로 끝나는 파일에    testing 패키지를 임포트하고    func BenchmarkXxxx(b *testing.B) 형태로 함수를 작성하면 됩니다.    한 번 작성해 봅시다. (소스코드는 이전 포스트의 n이하의 소수의 개수를 리턴하는 함수 prime(n)를 참고하세요.)\n1 2 3 4 5 6 7 8 9 10  // prime_test.go package main import \u0026#34;testing\u0026#34; func BenchmarkPrime(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { prime(1000) } }   유의미한 시간 차이를 보일때까지 b.N은 알아서 조정됩니다.\n터미널에 go test -bench .를 입력하여 벤치마크 결과를 볼 수 있습니다.\n1 2 3 4 5 6 7 8 9  PS C:\\dev\\goproject\\prime\u0026gt; go test -bench . goos: windows goarch: amd64 pkg: prime cpu: Intel(R) Core(TM) i5-10400F CPU @ 2.90GHz BenchmarkPrime-12 29833 40675 ns/op PASS ok prime 8.221s PS C:\\dev\\goproject\\prime\u0026gt;   먼저 os와 아키텍처, cpu에 대한 정보가 나옵니다.\nBenchmarkPrime-12 29833 40675 ns/op의 의미는 BenchmarkPrime() 함수가 29833번 반복되었으며, 한 번 시행마다 40675ns 만큼 걸렸다는 뜻입니다.\n BenchmarkPrime-12에서 12의 의미는 cpu가 가질 수 있는 최대 쓰레드 수 입니다. 즉, 이 컴퓨터에서는 한 순간에 최대 12개의 고루틴들이 병렬로 실행될 수 있습니다.\n 고루틴을 이용한 멀티쓰레딩 프로그래밍으로 prime() 함수를 조금 개선해 봅시다.\n","description":"","id":38,"section":"docs","tags":["golang","test","benchmark"],"title":"(2) : golang benchmark","uri":"https://lyra95.github.io/docs/go/go-benchmark/"},{"content":"conv gifs\n블로그\nConvTranspose docs\nA guide to convolution arithmetic for deep learning\nblog ConvT\n","description":"","id":39,"section":"docs","tags":[],"title":"Convolution (draft)","uri":"https://lyra95.github.io/docs/ml/convolution/"},{"content":"데이터 중복 문제 다음과 같이 topic table이 있습니다.\n1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt;select*fromtopic;+----+------------+--------------------+---------------------+--------+--------------------------+ |id|title|description|created|author|profile|+----+------------+--------------------+---------------------+--------+--------------------------+ |1|MySQL|MySQLis...|2018-01-1000:00:00|egoing|developer||2|ORACLE|Oracleis...|2021-05-0618:17:04|egoing|developer||3|SQLServer|SQLServeris...|2021-05-0620:20:24|duru|databaseadministrator||4|PostgreSQL|PostgreSQLis...|2021-05-0618:27:24|taeho|datascientist,developer||5|MongoDB|MongoDBis...|2021-05-0618:27:43|egoing|developer|+----+------------+--------------------+---------------------+--------+--------------------------+ 5rowsinset(0.00sec)  (author,profile)을 보면 (\u0026lsquo;egoing\u0026rsquo;,\u0026lsquo;developer\u0026rsquo;)가 전체 5개 레코드 중 3개의 레코드에서 반복되고 있습니다.\n만일 테이블이 훨씬 더 큰 사이즈여서 몇 만, 십 만 단위의 레코드가 있었더라면 저렇게 특정한 데이터들이 반복되지 않는게 좋습니다. 데이터의 크기가 몇 기가바이트 단위로 커도 역시 반복되지 않는게 좋습니다.\n테이블에 반복되는 데이터가 있으면 어떻게 해야할까요?\n테이블 나누기 topic table을 둘로 나누어 봅시다.\n원본을 일단 백업합니다.\n1 2  mysql\u0026gt;RENAMETABLEtopicTOtable_backup;QueryOK,0rowsaffected(0.01sec)  새로 topic, author라는 테이블을 만듭니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  mysql\u0026gt;CREATETABLEtopic(-\u0026gt;idINT(11)NOTNULLAUTO_INCREMENT,-\u0026gt;titleVARCHAR(30)NOTNULL,-\u0026gt;descriptionTEXTNULL,-\u0026gt;createdDATETIMENOTNULL,-\u0026gt;author_idINT(11)NULL,-\u0026gt;PRIMARYKEY(id)-\u0026gt;);QueryOK,0rowsaffected,2warnings(0.02sec)mysql\u0026gt;CREATETABLEauthor(-\u0026gt;idINT(11)NOTNULLAUTO_INCREMENT,-\u0026gt;nameVARCHAR(20)NOTNULL,-\u0026gt;profileVARCHAR(200)NULL,-\u0026gt;PRIMARYKEY(id)-\u0026gt;);QueryOK,0rowsaffected,1warning(0.02sec)  레코드도 추가해줍니다. author 테이블은 아래와 같습니다.\n1 2 3 4 5 6 7 8 9  mysql\u0026gt;SELECT*FROMauthor;+----+--------+---------------------------+ |id|name|profile|+----+--------+---------------------------+ |1|egoing|developer||2|duru|databaseadministrator||3|taeho|datascientist,developer|+----+--------+---------------------------+ 3rowsinset(0.00sec)  원래의 topic 테이블에서, (\u0026lsquo;egoing\u0026rsquo;,\u0026lsquo;developer\u0026rsquo;)를 갖던 레코드는 이제 author_id 값으로 1을 갖습니다.\n1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt;SELECT*FROMtopic;+----+------------+------------------+---------------------+-----------+ |id|title|description|created|author_id|+----+------------+------------------+---------------------+-----------+ |1|MySQL|MySQLis...|2021-05-0623:09:59|1||2|ORACLE|ORACLEis...|2021-05-0623:10:21|1||3|SQLServer|SQLServeris...|2021-05-0623:10:55|2||4|PostgreSQL|PostgreSQLis...|2021-05-0623:11:28|3||5|MongoDB|MongoDBis...|2021-05-0623:11:53|1|+----+------------+------------------+---------------------+-----------+ 5rowsinset(0.00sec)  이제 (\u0026lsquo;egoing\u0026rsquo;,\u0026lsquo;developer\u0026rsquo;)이 반복 저장되지않고, 대신 author_id=1 값이 반복 저장됩니다.\n topic 테이블의 author_id 같은 attribute를 외래키(foreign key)라고 부릅니다.\n JOIN으로 합쳐서 보기 다음과 같은 커맨드로 두 테이블을 합쳐서 볼 수 있습니다.\n1 2 3 4 5 6 7 8 9 10 11  mysql\u0026gt;SELECT*FROMtopicLEFTJOINauthorONtopic.author_id=author.id;+----+------------+------------------+---------------------+-----------+------+--------+---------------------------+ |id|title|description|created|author_id|id|name|profile|+----+------------+------------------+---------------------+-----------+------+--------+---------------------------+ |1|MySQL|MySQLis...|2021-05-0623:09:59|1|1|egoing|developer||2|ORACLE|ORACLEis...|2021-05-0623:10:21|1|1|egoing|developer||3|SQLServer|SQLServeris...|2021-05-0623:10:55|2|2|duru|databaseadministrator||4|PostgreSQL|PostgreSQLis...|2021-05-0623:11:28|3|3|taeho|datascientist,developer||5|MongoDB|MongoDBis...|2021-05-0623:11:53|1|1|egoing|developer|+----+------------+------------------+---------------------+-----------+------+--------+---------------------------+ 5rowsinset(0.00sec)  author_id와 그 옆의 id attribute를 빼고 보고 싶으면 다음과 같이 하면 됩니다. 합치기 전의 테이블과 똑같이 생겼습니다!\n1 2 3 4 5 6 7 8 9 10 11 12  mysql\u0026gt;SELECTtopic.id,title,description,created,name,profile-\u0026gt;FROMtopicLEFTJOINauthorONtopic.author_id=author.id;+----+------------+------------------+---------------------+--------+---------------------------+ |id|title|description|created|name|profile|+----+------------+------------------+---------------------+--------+---------------------------+ |1|MySQL|MySQLis...|2021-05-0623:09:59|egoing|developer||2|ORACLE|ORACLEis...|2021-05-0623:10:21|egoing|developer||3|SQLServer|SQLServeris...|2021-05-0623:10:55|duru|databaseadministrator||4|PostgreSQL|PostgreSQLis...|2021-05-0623:11:28|taeho|datascientist,developer||5|MongoDB|MongoDBis...|2021-05-0623:11:53|egoing|developer|+----+------------+------------------+---------------------+--------+---------------------------+ 5rowsinset(0.00sec)   topic 테이블과 author 테이블 둘 다 id라는 attribute가 있습니다. {테이블이름}.id로 둘을 구분할 수 있습니다.  중복되는 데이터는 분리해서 저장하되, JOIN을 통해 다시 원래처럼 합쳐서 볼 수 있습니다.\n JOIN도 더 복잡한 문법들이 있지만, 아이디어만을 보여주기 위해 생략합니다.\n 튜토리얼 코스는 여기까지 입니다. 정규화, 데이터베이스 모델링, java/c++같은 언어로 데이터베이스와 소통하기 등 많은 것들이 남아있지만 차차 알아봅시다.\n","description":"","id":40,"section":"docs","tags":["mysql","db","join"],"title":"(6) : JOIN, 데이터 중복 최소화","uri":"https://lyra95.github.io/docs/mysqltutorial/mysql-6/"},{"content":"시작하기 전에 스레드, 프로세스, 컨텍스트 스위칭에대한 개념을 알고 있으면 도움이 됩니다. 몰라도 당장에는 대략적으로 이해할 수는 있겠지만 이번 기회에 알아두는 것도 좋습니다.\ngo Routine func foo()라는 함수가 있다고 합시다.\ngo foo()로 고루틴(스레드)를 생성함과 동시에 생성된 고루틴에서 foo() 함수가 수행됩니다.\n1 2 3 4 5 6 7 8 9 10  func foo() { fmt.Print(\u0026#34;Hi from new Go routine\u0026#34;) } func main() { go foo() go foo() go foo() fmt.Println(\u0026#34;Hi from Go routine main\u0026#34;) }    main 함수도 고루틴의 일종입니다.\n 이 프로그램을 실행하면 어떻게 될까요?\n1 2 3 4 5 6 7  PS C:\\dev\\goproject\\prime\\test\u0026gt; ./test.exe Hi from Go routine main PS C:\\dev\\goproject\\prime\\test\u0026gt; ./test.exe Hi from new Go routine Hi from new Go routine Hi from new Go routine Hi from Go routine main   답은 \u0026ldquo;모른다\u0026rdquo; 입니다. 4개의 고루틴( foo 3개, main 1개) 중 어느 것이 먼저 실행되고 끝날지는 OS 프로그램의 마음대로입니다.\n3개의 foo 고루틴이 끝나기전에 main 고루틴이 끝나버리면, 실행이 끝나지 않은 foo 고루틴들도 강제로 끝나버립니다.\nWaitGroup 어떻게해야 main 고루틴에서 foo 서브 고루틴들이 정상적으로 끝날 때까지 기다리게 할 수 있을까요?\n한가지 답은 WaitGroup 오브젝트입니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; // 1. WaitGroup이 포함된 패키지 임포트 ) func foo(wg *sync.WaitGroup) { // 2. WaitGroup Obj를 pass by ref로 받습니다. \tfmt.Println(\u0026#34;Hi from new Go routine\u0026#34;) wg.Done() // 3. foo가 완료되었다고 알립니다. } func main() { var wg sync.WaitGroup // 4. WaitGroup Obj를 생성합니다. \twg.Add(3) // 5. 3개의 foo 고루틴을 기다려야 한다고 알립니다.  go foo(\u0026amp;wg) // 6. WaitGroup Obj의 reference를 pass합니다. \tgo foo(\u0026amp;wg) go foo(\u0026amp;wg) fmt.Println(\u0026#34;Hi from Go routine main\u0026#34;) wg.Wait() // 7. foo 고루틴이 다 끝날때까지 기다립니다 \u0026lt;=\u0026gt; wg.Done()이 3번 call되기를 기다립니다. }    \u0026amp;,*가 뭔지 모르겠다면 포인터, pass by value/reference 개념을 공부해보세요\n 프로그램을 실행해 봅시다.\n1 2 3 4 5 6 7 8 9 10  PS C:\\dev\\goproject\\prime\\test\u0026gt; ./test.exe Hi from new Go routine Hi from Go routine main Hi from new Go routine Hi from new Go routine PS C:\\dev\\goproject\\prime\\test\u0026gt; ./test.exe Hi from Go routine main Hi from new Go routine Hi from new Go routine Hi from new Go routine   foo()가 3번 실행되고는 있지만 Hi from Go routine main가 몇 번째로 출력될지는 알 수 없습니다. Hi from Go routine main가 마지막에 출력되게 하려면 어떻게 해야할까요?\n간단합니다. wg.Wait()과 fmt.Print()의 순서를 바꿔주면 됩니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24  package main import ( \u0026#34;fmt\u0026#34; \u0026#34;sync\u0026#34; ) func foo(wg *sync.WaitGroup) { fmt.Println(\u0026#34;Hi from new Go routine\u0026#34;) wg.Done() } func main() { var wg sync.WaitGroup wg.Add(3) go foo(\u0026amp;wg) go foo(\u0026amp;wg) go foo(\u0026amp;wg) wg.Wait() fmt.Println(\u0026#34;Hi from Go routine main\u0026#34;) }   이제 프로그램을 실행해보면 Hi from Go routine main이 마지막에 출력됩니다.\n1 2 3 4 5 6 7 8 9 10  PS C:\\dev\\goproject\\prime\\test\u0026gt; ./test.exe Hi from new Go routine Hi from new Go routine Hi from new Go routine Hi from Go routine main PS C:\\dev\\goproject\\prime\\test\u0026gt; ./test.exe Hi from new Go routine Hi from new Go routine Hi from new Go routine Hi from Go routine main   ","description":"","id":41,"section":"docs","tags":["golang","goroutine"],"title":"(3)-1 : golang goRoutine","uri":"https://lyra95.github.io/docs/go/go-goroutine/"},{"content":"이제 goRoutine을 활용해봅니다. 다음 두 함수를 prime.go에 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29  // prime.go func prime_(start, end int, handle *int, wg *sync.WaitGroup) { cnt := 0 for i := start; i \u0026lt;= end; i++ { if isPrime(i) { cnt++ } } defer wg.Done() *handle = cnt } func prime_multi(n int) int { mid := n / 2 var wg sync.WaitGroup wg.Add(2) handle1 := 0 go prime_(1, mid, \u0026amp;handle1, \u0026amp;wg) handle2 := 0 go prime_(mid+1, n, \u0026amp;handle2, \u0026amp;wg) wg.Wait() return handle1 + handle2 }   prime_()은 [start, end] 사이의 소수의 개수를 구하여, 개수를 handle 포인터에 저장합니다. 그리고 wg.Done()으로 작업이 끝났음을 알립니다.\nprime_multi()는 [1,n]을 [1,mid],[mid+1,n]으로 작업을 둘로 나누어 동시에 진행하여 소수의 개수를 구합니다.\n벤치마크 비교하기 prime_test.go에 다음을 추가합니다.\n1 2 3 4 5 6 7 8 9 10 11 12  // prime_test.go func BenchmarkPrime(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { prime(1000) } } func BenchmarkPrimeM(b *testing.B) { for i := 0; i \u0026lt; b.N; i++ { prime_multi(1000) } }   go test -bench .를 실행하면 go가 알아서 b.N을 키워가며 성능 비교를 해줍니다.\n1 2 3 4 5 6 7 8 9  PS C:\\dev\\goproject\\prime\u0026gt; go test -bench . goos: windows goarch: amd64 pkg: prime cpu: Intel(R) Core(TM) i5-10400F CPU @ 2.90GHz BenchmarkPrime-12 24724 41346 ns/op BenchmarkPrimeM-12 41620 28654 ns/op PASS ok prime 3.089s   같은 시간동안 BenchmarkPrimeM()이 BenchmarkPrime() 보다 두배가까이 더 많이 실행됬습니다.(41620 \u0026gt; 24724) 또한, 한 번 실행 당 걸린 시간도 더 짧습니다.(28654 ns \u0026lt; 41346 ns)\n","description":"","id":42,"section":"docs","tags":["golang","goroutine"],"title":"(3)-2 : goRoutine으로 prime 개선 (draft)","uri":"https://lyra95.github.io/docs/go/go-goroutine2/"},{"content":"(https://github.com/lyra95/chat-server-client-with-golang/tree/master)[https://github.com/lyra95/chat-server-client-with-golang/tree/master]\n(진행중)\n","description":"","id":43,"section":"docs","tags":["golang","server","net","cuncurrency"],"title":"Chat Server Client With Golang (draft)","uri":"https://lyra95.github.io/docs/go/chat-server-client-with-golang/"},{"content":"Is it safe to remove selected keys from map within a range loop?\ndelete(map,key)가 실제로 delete를 행하는게 아니라 그냥 flag를 setting할 뿐이라고 한다. 그래서 다음과 같은 코드를 작성해도 괜찮다.\n1 2 3 4  for key, value := range table { fmt.Printf(\u0026#34;deleting %v=\u0026gt;%v\\n\u0026#34;, key, value.value) delete(table, key) }   ","description":"","id":44,"section":"docs","tags":["golang"],"title":"Deleting Key in Map While Ranging Is Safe","uri":"https://lyra95.github.io/docs/go/deleting-key-while-ranging-is-safe/"},{"content":"https://pkg.go.dev/path/filepath#Walk\n1 2 3 4 5 6 7  // func Walk(root string, fn WalkFunc) error err := filepath.Walk(root, // type WalkFunc func(path string, info fs.FileInfo, err error) error  func(path string, info fs.FileInfo, err error) error { // do what you want to do with each file/directory, including root  } )   ","description":"","id":45,"section":"docs","tags":["filepath"],"title":"filepath.Walk로 디렉토리 순회하기","uri":"https://lyra95.github.io/docs/go/walk/"},{"content":"https://golang.org/pkg/strings/\n스트링 관련 많은 함수들을 제공한다. 몇가지 예를 들면\nfunc Contains(s, substr string) bool\nfunc HasSuffix(s, suffix string) bool\nfunc Index(s, substr string) int (첫번째 index)\nfunc Split(s, sep string) []string\nfunc Replace(s, old, new string, n int) string (n개의 old를 new로 치환한 카피 리턴)\nfunc ToUpper(s string) string\nfunc TrimRight(s string, cutset string) (string)\n1 2  fmt.Print(strings.TrimRight(\u0026#34;¡¡¡Hello, Gophers!!!\u0026#34;, \u0026#34;!¡\u0026#34;)) // ¡¡¡Hello, Gophers   ","description":"","id":46,"section":"docs","tags":["package"],"title":"strings 패키지","uri":"https://lyra95.github.io/docs/go/strings/"},{"content":"1 2 3 4 5  // 이미 있는지 확인 if _, err := os.Stat(path); os.IsNotExist(err) { // 없으므로 생성 \te := os.Mkdir(path, os.ModeDir) }   ","description":"","id":47,"section":"docs","tags":["os"],"title":"디렉토리 유무확인/생성하기","uri":"https://lyra95.github.io/docs/go/mkdir/"},{"content":"fmt.SprintF(s string, a ...interface{}) string로 가능\n1 2  var tmp string tmp = fmt.Sprintf(\u0026#34;// Date : %v %v %v\\n\u0026#34;, year, month, day)   ","description":"","id":48,"section":"docs","tags":["golang","string"],"title":"Print하지 않고 Format String 쓰기","uri":"https://lyra95.github.io/docs/go/format-string/"},{"content":"방법이 너무 다양해서 하나 통일해서 정할 필요가 있어보인다.\nREAD  os.ReadFile(path string) ([]byte, error) os.Open(path string) (*os.File , error)로 file handle을 정의해서file.Read(buffer []byte) (int n, error)를 사용하는 방법 file handle로 bufio.NewReader(file io.Reader) *bufio.Scanner를 정의해서 .Read/.ReadByte/.ReadBytes/.ReadLine/.ReadRune/.ReadString/.ReadSlice를 사용하는 방법 file handle로 bufio.NewReader(file io.Reader) *bufio.Scanner를 정의해서 .Scan(),.Split() 과 .Text()를 사용하는 방법   https://pkg.go.dev/bufio#Scanner example 참고\n 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  // 1 // 파일을 열어서 내용물 전체를 []byte로 받는다. result,_ := os.ReadFile(path) // 2 file,_ := os.Open(path) defer file.Close() var buffer [100]byte // 주어진 버퍼 크기만큼 데이터를 담는다. result,_ := file.Read(buffer) // 3 file,_ := os.Open(path) defer file.Close() scanner := bufio.NewReader(file) // \u0026#39;\\n\u0026#39;이 나올때까지 읽어서 string으로 받는다. result, _ := scanner.ReadString(byte(\u0026#39;\\n\u0026#39;)) // 4 file,_ := os.Open(path) defer file.Close() scanner := bufio.NewReader(file) // Split 기준을 단어 단위로 한다. 디폴트는 newline이다. scanner.Split(bufio.ScanWords) // 다음 토큰까지 scanner를 진행한다. if scanner.Scan() { // 읽은 토큰을 string으로 받는다. \tresult, _ = scanner.Text() // 예시: 123 4567 jojo -\u0026gt; 123, 4567, jojo 이렇게 단어 단위로 읽음 }   WRITE 파일을 생성하고 write 1 2 3 4 5  file, _ := os.Create(path) defer file.Close() w := bufio.NewWriter(file) w.WriteString(text) w.Flush()   기존 파일을 trunc 후 write 1 2 3 4 5 6  // OpenFile(name string, flag int, perm FileMode) (*File, error) file, _ := os.OpenFile(path, os.O_WRONLY|os.O_TRUNC, 0644) defer file.Close() w := bufio.NewWriter(file) w.WriteString(text) w.Flush()    os.O_WRONLY은 write-only, os.O_TRUNC은 trunucation을 의미한다. FileMode는 좀 더 알아봐야 할 듯  Read든 Write든 bufio를 쓰는 방향으로 통일하는게 좋겠다.\n","description":"","id":49,"section":"docs","tags":["golang","file","read","write"],"title":"file read write 하는 법","uri":"https://lyra95.github.io/docs/go/file_read_write.md/"},{"content":"strconv 패키지에 string, int를 변환하는 함수들이 있다.\nstrconv.Atoi(s string) (int,erorr)로 string-\u0026gt;int\nstrconv.ItoA(n int) string로 int-\u0026gt;string\n","description":"","id":50,"section":"docs","tags":["golang","package"],"title":"String \u003c-\u003e Int 변환하기","uri":"https://lyra95.github.io/docs/go/strconv/"},{"content":"Scan을 할 때, 인풋 버퍼를 비우지 않으면 엉뚱한 값을 입력 받을 수 있으니 인풋 버퍼를 비우는게 좋다.\n비우는 방법:\n1 2 3 4 5 6  import ( \u0026#34;os\u0026#34; \u0026#34;bufio\u0026#34; ) stdin := bufio.NewReader(os.Stdin) stdin.ReadString(\u0026#39;\\n\u0026#39;) // \u0026#39;\\n\u0026#39;이 나올때까지 버퍼를 읽는다.   ","description":"","id":51,"section":"docs","tags":["golang"],"title":"Input Buffer Flush하기","uri":"https://lyra95.github.io/docs/go/flush/"},{"content":"지금까지 읽은 책, 수강한 코스, 시청한 유튜브 채널을 리뷰하고 추천하는 글입니다.\nComputer Science General   Crash Course: Computer Science (10/10)\n전산학과/컴공 입문생에게 \u0026ldquo;대충 너가 4년간 배울 내용이 이거야\u0026quot;하고 보여주고 싶다. 종이에 구멍 뚫던 시절 이야기, 트랜지스터로 논리 게이트 짜기, cpu/register bus, OS, Network 등등 없는 얘기가 없다. 이거 본다고 갑자기 Node.js 다룰 줄 알게되거나 하는 건 아니지만, 자신이 컴공상식이 부족하다고 생각되면 보길.\nOS편 어느 컴공 대학생의 코멘트: \u0026ldquo;Two semesters in 12 minutes. That\u0026rsquo;s efficiency.\u0026rdquo;\n  Language   Tucker의 Go 언어 프로그래밍 (10/10)\nGo를 배우는 목적이 아니더라도 전산학과/컴퓨터공학과 입문생에게 추천하고 싶은 책.\n  모던 C++ 디자인 패턴 (0/10)\n책 구성이 별로여서 잘 읽히지 않음. 번역체 심함.\n여기에서 원문으로 공부하는게 더 나을 듯.\n  Effective Modern C++, Scott Meyers (8/10)\nc++을 근사하게(그리고 모-던하게) 쓰고 싶으면 꼭 읽어야할 책. 다만 C++은 슬슬 놓아줘야할 언어인게 아닐까?\n  Programming Principles and Practice Using C++, Bjarne Stroustrup (8/10)\nC++ 크리에이터가 쓴 C++책. 프로그래밍 입문생에게 추천하고 싶다. 단순 이론말고도 저자 본인의 경험에서 우러나오는 충고들이 보석 같다. 책이 너무 두껍다. C++이라서 2점 깎음\n  Rust Doc (8/10)\nRust를 쉽게 배우는 법: C++을 배우고 고구마 100개 먹은 기분으로 rust doc을 본다. 한글번역\n  Network, Server   게임 서버 프로그래밍 교과서 (8/10)\n옛날에는 이렇게 일일이 손으로 다 했데요~ 하는 전래동화 읽는 마음으로 보는 책\n  유니티 네트워크 프로그래밍 (반다이 남코 현역 프로그래머가 알려주는) (6/10)\n유니티 2020.3.2f1 기준 작동하지 않는 코드들이 많다. 책의 예제에서 활용한 그래픽 리소스 같은 것도 없고 클라이언트 부분 예제 코드도 없다. 사실상 따라하기 불가능.\n  Graphics   3D 게임을 움직이는 수학과 물리 (5/10)\nwindows 10 64bit 기준 작동하지 않는 코드들 이 있다.(\u0026lt;d3dx9.h\u0026gt; 따위가 windows sdk에 포함되지 않아서 알아서 받아야 함)\nDirectX3D 엔진을 가볍게 배우고자 산 책인데, 그런 설명은 없고 구 같은 도형을 어케 그릴지만 나와있다.(코드 500줄 중에 구를 그리는 파트는 30줄 정도고 나머지는 설명이 없는 directx 구동하는 부분.)\n  Foundations of 3D Computer Graphics, Steven J. Gortler (읽는 중) (8/10)\nOpenGL과 hello하기 위해 매우 고통스러운 것을 빼면 좋은 책. 이론 설명이 깔끔하고 연습 문제도 좋고 예제도 좋고(openGL 셋팅에 성공했다면)\n  The Cherno의 openGL course (유튜브) (10/10)\n3년 전부터 업뎃도 안하고 애플도 지원을 끊겟다고 선언한 레거시 천지의 openGL을 머리를 쥐어뜯으며 셋팅하고 있을 때 발견했다.(드디어 뭔가 작동하는 걸 설명하는 사람을 발견했어 ㅠㅠ) visual studio 사용법도 겸사겸사 익힐 수 있고, 현업자 기준 좋은 팁들을 준다.\n  Game Engine   그림으로 이해하고 만들면서 익히는 유니티 교과서 개정 4판 (9/10)\n유니티를 처음 배우는 중고등학생에게 좋은 책인듯.\n  Algorithm \u0026amp; Data Structures   Data structures and algorithm analysis in c++, 4th edition, Mark Allen Weiss (10/10)\nC++ ds책은 일단 절반이 modern이 아니거나, 대충이거나 하는데 이 책은 완벽하다.(두꺼운게 흠이지만\u0026hellip;) 설명이 매우 디테일하다(아저씨 이미 내 뇌는 새 정보를 거부하고 있어ㅜㅜ) 코드도 귀찮을 텐데 완벽히 다 작성해놨다.\n  Deeplearning   Deep Learning with PyTorch (10/10)\npytorch 공식 가이드북. 하도 AI거리니까 나도 알아는 봐야겠는데 쓸데없는 정보의 홍수 속에서 발견한 보물. 셋팅, 이론, 예제 삼박자가 완벽\n  기타 url 딥러닝을 이용한 자연어 처리 입문\npytorch로 시작하는 딥러닝 입문\npytorch docs\npytorch lightning bolt docs\npytorch lightning docs\n점프 투 파이썬\n","description":"","id":52,"section":"docs","tags":["review","book","youtube","course"],"title":"Reviews","uri":"https://lyra95.github.io/docs/book-review/"},{"content":"Item4: Deduced type 확인하기 A. 에디터에 마우스 갖다대면 뜸 B. 컴파일러로 확인하기 다음과 같이 Declaration만 있고 Definition은 없는 class를 정의하자.\n1 2 3 4 5 6 7 8  template\u0026lt;typename T\u0026gt; // declaration only for TD; class TD; // TD == \u0026#34;Type Displayer\u0026#34;  int x; const int *y; // x랑 y의 type을 알고 싶다면... TD\u0026lt;decltype(x)\u0026gt; xType; // elicit errors containing TD\u0026lt;decltype(y)\u0026gt; yType; // x\u0026#39;s and y\u0026#39;s types   컴파일하면 컴파일러가 에러메세지로 deduced type을 알려준다.\n1 2  error: \u0026#39;xType\u0026#39; uses undefined class \u0026#39;TD\u0026lt;int\u0026gt;\u0026#39; error: \u0026#39;yType\u0026#39; uses undefined class \u0026#39;TD\u0026lt;const int *\u0026gt;\u0026#39;   C. Run Time에 확인하기 1 2  std::cout \u0026lt;\u0026lt; typeid(x).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // display types for std::cout \u0026lt;\u0026lt; typeid(y).name() \u0026lt;\u0026lt; \u0026#39;\\n\u0026#39;; // x and y   컴파일러 종류에 따라 다른 이름이 출력된다.\ngcc\n i=int, PK=Pointer to Const, PKi = Pointer to Const int\n microsoft\n int const * = const int *\n type_id::name은 reference-ness를 무시할 때가 있으니, 정확한 걸 바라면 Boost::type_index라는 외부 라이브러리를 쓰자.\nitem5: auto 적재적소에 쓰기 A. declaration시 type이 너무 길 때; 1 2 3 4  auto derefUPLess = // comparison func.  [](const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; p1, // for Widgets  const std::unique_ptr\u0026lt;Widget\u0026gt;\u0026amp; p2) // pointed to by  { return *p1 \u0026lt; *p2; }; // std::unique_ptrs   한 술 더 떠서 parameter type에도 auto를 써도된다.\n1 2 3 4  auto derefUPLess = // comparison func.  [](const auto\u0026amp; p1, const auto\u0026amp; p2) { return *p1 \u0026lt; *p2; };   B. 별 중요하지 않은 type이 헷갈릴때 1 2 3 4  std::vector\u0026lt;int\u0026gt; v; … unsigned sz = v.size(); auto sz_ = v.size();   사실 std::size의 return type은 std::vector::size_type인데도 다들 잘 모르고 unsigned를 쓴다.\n중요하지 않은데 헷갈린다. 그냥 auto를 쓰자.\n예시 하나 더\n1 2 3 4 5 6 7 8 9 10  std::unordered_map\u0026lt;std::string, int\u0026gt; m; … for (const std::pair\u0026lt;std::string, int\u0026gt;\u0026amp; p : m) // are you sure with the type? { … // do something with p } for (const auto\u0026amp; p : m) { … // do something with p }   item6: auto 주의사항 1 2 3  std::vector\u0026lt;bool\u0026gt; features(const Widget\u0026amp; w); // a bool vector  auto highPriority = features(w)[5]; // this isn\u0026#39;t bool, unfortunately   std::vector의 구현은 다른 type의 vector들과 다르다: 메모리 사용량을 줄이기 위해, 각 bit가 true/false를 저장하도록 되어있다.\nstd::vector::operator[ ]의 type signature를 보면,\n1 2 3 4 5 6 7 8 9 10  namespace std { // from C++ Standards  template \u0026lt;class Allocator\u0026gt; class vector\u0026lt;bool, Allocator\u0026gt; { public: … class reference { … }; reference operator[](size_type n); … }; }   return type이 bool이 아니다! 그래서 auto는 bool을 deduce하지 않는다.\n비슷하게 matrix class에서도 auto의 type deduction이 가끔 이상할 수 가 있다.\n대체 언제 auto를 쓰고 언제 쓰지 말아야할까?\n standard library 구현을 잘 숙지하던가 static_cast\u0026lt;\u0026gt;를 쓰던가  1  auto highPriority = static_cast\u0026lt;bool\u0026gt;(features(w)[5]);   ","description":"","id":53,"section":"docs","tags":["c++","auto","type deduction"],"title":"Effective Modern C++(1)","uri":"https://lyra95.github.io/docs/cpp/effective-cpp/"},{"content":"Sequence Containers vector 기본 array의 강화판. array는 size 정보도 가지고 있지 않고, index bound error도 컴파일 타임에 체크해 주지 않는다. 반면에 vector는 다음과 같은 특징이 있다.\n[+] memory에 연속적으로 element들을 저장한다.\n[+] .size()를 통해 현재 element 개수를 알 수 있다.\n[+] array와 마찬가지로 constant time element access가 가능하다.\n[+] .at()같은 index bound를 체크해주는 member function들이 있다.\n[+] heap allocation 알아서 해준다. int x[n] 에러의 악몽\n[-] 타이핑하기 귀찮다 vector\u0026lt;vector\u0026lt;\u0026hellip;\u0026raquo;\n그러니 잘 모르겠으면 vector를 쓰자.\n  양방향 iterator\n  iterator + int 가능\n  iterator - iterator 가능\n  push_back: amortized O(1)\n 현재 배정된 메모리에 여유가 있으면 O(1). 자리가 부족하면 새로운 메모리에 복사되서 새로 배정되느라 O(n)\n   pop_back: O(1)\n  보통 constructor는 {}를 쓰는게 국룰이지만, vector의 경우 어쩔 수없이 ()를 쓰게될 때가 있다.\n vector\u0026lt;\u0026gt;(uint size, T val) // val을 size개수만큼.\n array deque list 구현기반: doubly linked list\nforward_list Container Adapters queue priority queue stack Associative Containers map 구현기반: balanced binary tree\nsupported operations:\nunordered map 구현기반: hash\nset unorderd set ","description":"","id":54,"section":"docs","tags":["c++","algorithm","data structure"],"title":"C++ containers in standard library (draft)","uri":"https://lyra95.github.io/docs/cpp/cpp-standard-library-containers/"},{"content":"Error Description mingw-w64-install.exe를 실행했을때, 설치가 완료되지 못 함. 다음과 같은 에러메세지 출력됨.\n the file has been downloaded incorrectly\n To Reproduce the error windows 10 pro 64bit\nmingw-w64-install.exe 실행\n설치경로 C:\\\n   Option Selected     version 8.1.0   Architecture x86_64   Thread posix   Exception seh   Build revision 0    Solution x86_64-win32-seh zip 파일 다운로드\n설치하려던 경로에 압축풀기 후, 환경변수 PATH에 설치경로/mingw64/bin 등록\nPS  왜 win32버전으로 까는가? 필자는 간단하게 코테 문제들 풀려고 gcc 컴파일러를 쓰기 위해 mingw까는 중이다. 별 상관없이 잘 돌아간다. 그리고 posix zip파일을 받아보면 안에 bin도 없고 어케쓰는건지 모르겠음  ","description":"","id":55,"section":"docs","tags":["mingw","windows","config"],"title":"MINGW64 설치오류 the file has been downloaded incorrectly","uri":"https://lyra95.github.io/docs/configurations/mingw-install/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\n Headings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae.\nNote that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\n Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;  Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10  \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;   List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item  First Sub-item Second Sub-item    Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL+ALT+Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\n The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n  ","description":"","id":56,"section":"blog","tags":["markdown","css","html","themes"],"title":"Markdown Syntax Guide","uri":"https://lyra95.github.io/blog/markdown-syntax/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nHugo ships with several Built-in Shortcodes for rich content, along with a Privacy Config and a set of Simple Shortcodes that enable static and no-JS versions of various social media embeds.\n YouTube Privacy Enhanced Shortcode   Twitter Simple Shortcode .twitter-tweet { font: 14px/1.45 -apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif; border-left: 4px solid #2b7bb9; padding-left: 1.5em; color: #555; } .twitter-tweet a { color: #2b7bb9; text-decoration: none; } blockquote.twitter-tweet a:hover, blockquote.twitter-tweet a:focus { text-decoration: underline; }  “In addition to being more logical, asymmetry has the advantage that its complete appearance is far more optically effective than symmetry.”\n— Jan Tschichold pic.twitter.com/gcv7SrhvJb\n\u0026mdash; Graphic Design History (@DesignReviewed) January 17, 2019 Vimeo Simple Shortcode  .__h_video { position: relative; padding-bottom: 56.23%; height: 0; overflow: hidden; width: 100%; background: #000; } .__h_video img { width: 100%; height: auto; color: #000; } .__h_video .play { height: 72px; width: 72px; left: 50%; top: 50%; margin-left: -36px; margin-top: -36px; position: absolute; cursor: pointer; }  ","description":"","id":57,"section":"blog","tags":["shortcodes","privacy"],"title":"Rich Content","uri":"https://lyra95.github.io/blog/rich-content/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\ninhospita parcite confusaque translucet patri vestro qui optatis\nlumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus\nsilentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria\ntractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt \nThe Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra\ndicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere\nfurit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli\nLelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare\nEchionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert\nausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae\nvulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem\nPropoetides parte.\n","description":"","id":58,"section":"blog","tags":["markdown","text"],"title":"Placeholder Text","uri":"https://lyra95.github.io/blog/placeholder-text/"},{"content":"Lorem est tota propiore conpellat pectoribus de\npectora summo. Redit teque digerit hominumque toris verebor lumina non cervice\nsubde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc\ncaluere tempus\nEmoji can be enabled in a Hugo project in a number of ways.\n The emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 🙈 🙉 🙉 🙊 🙊\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3  .emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }  ","description":"","id":59,"section":"blog","tags":["emoji"],"title":"Emoji Support","uri":"https://lyra95.github.io/blog/emoji-support/"}]